<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>MSC Tool for LTE and NR</title>
        
        <script src='../asn1_js/brython.js'></script>
        <script src='../asn1_js/3gppdata.js'></script>
        
        
        
        
        
        <script>


/*
 * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $
 *
 * Original:
 *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt
 */

// if run as a web worker, respond to messages by deflating them
var deflate = (function() {

/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0.1
 * LastModified: Dec 25 1999
 */

/* Interface:
 * data = deflate(src);
 */

/* constant parameters */
var zip_WSIZE = 32768;		// Sliding Window size
var zip_STORED_BLOCK = 0;
var zip_STATIC_TREES = 1;
var zip_DYN_TREES    = 2;

/* for deflate */
var zip_DEFAULT_LEVEL = 6;
var zip_FULL_SEARCH = true;
var zip_INBUFSIZ = 32768;	// Input buffer size
var zip_INBUF_EXTRA = 64;	// Extra buffer
var zip_OUTBUFSIZ = 1024 * 8;
var zip_window_size = 2 * zip_WSIZE;
var zip_MIN_MATCH = 3;
var zip_MAX_MATCH = 258;
var zip_BITS = 16;
// for SMALL_MEM
var zip_LIT_BUFSIZE = 0x2000;
var zip_HASH_BITS = 13;
// for MEDIUM_MEM
// var zip_LIT_BUFSIZE = 0x4000;
// var zip_HASH_BITS = 14;
// for BIG_MEM
// var zip_LIT_BUFSIZE = 0x8000;
// var zip_HASH_BITS = 15;
//if(zip_LIT_BUFSIZE > zip_INBUFSIZ)
//    alert("error: zip_INBUFSIZ is too small");
//if((zip_WSIZE<<1) > (1<<zip_BITS))
//    alert("error: zip_WSIZE is too large");
//if(zip_HASH_BITS > zip_BITS-1)
//    alert("error: zip_HASH_BITS is too large");
//if(zip_HASH_BITS < 8 || zip_MAX_MATCH != 258)
//    alert("error: Code too clever");
var zip_DIST_BUFSIZE = zip_LIT_BUFSIZE;
var zip_HASH_SIZE = 1 << zip_HASH_BITS;
var zip_HASH_MASK = zip_HASH_SIZE - 1;
var zip_WMASK = zip_WSIZE - 1;
var zip_NIL = 0; // Tail of hash chains
var zip_TOO_FAR = 4096;
var zip_MIN_LOOKAHEAD = zip_MAX_MATCH + zip_MIN_MATCH + 1;
var zip_MAX_DIST = zip_WSIZE - zip_MIN_LOOKAHEAD;
var zip_SMALLEST = 1;
var zip_MAX_BITS = 15;
var zip_MAX_BL_BITS = 7;
var zip_LENGTH_CODES = 29;
var zip_LITERALS =256;
var zip_END_BLOCK = 256;
var zip_L_CODES = zip_LITERALS + 1 + zip_LENGTH_CODES;
var zip_D_CODES = 30;
var zip_BL_CODES = 19;
var zip_REP_3_6 = 16;
var zip_REPZ_3_10 = 17;
var zip_REPZ_11_138 = 18;
var zip_HEAP_SIZE = 2 * zip_L_CODES + 1;
var zip_H_SHIFT = parseInt((zip_HASH_BITS + zip_MIN_MATCH - 1) /
			   zip_MIN_MATCH);

/* variables */
var zip_free_queue;
var zip_qhead, zip_qtail;
var zip_initflag;
var zip_outbuf = null;
var zip_outcnt, zip_outoff;
var zip_complete;
var zip_window;
var zip_d_buf;
var zip_l_buf;
var zip_prev;
var zip_bi_buf;
var zip_bi_valid;
var zip_block_start;
var zip_ins_h;
var zip_hash_head;
var zip_prev_match;
var zip_match_available;
var zip_match_length;
var zip_prev_length;
var zip_strstart;
var zip_match_start;
var zip_eofile;
var zip_lookahead;
var zip_max_chain_length;
var zip_max_lazy_match;
var zip_compr_level;
var zip_good_match;
var zip_nice_match;
var zip_dyn_ltree;
var zip_dyn_dtree;
var zip_static_ltree;
var zip_static_dtree;
var zip_bl_tree;
var zip_l_desc;
var zip_d_desc;
var zip_bl_desc;
var zip_bl_count;
var zip_heap;
var zip_heap_len;
var zip_heap_max;
var zip_depth;
var zip_length_code;
var zip_dist_code;
var zip_base_length;
var zip_base_dist;
var zip_flag_buf;
var zip_last_lit;
var zip_last_dist;
var zip_last_flags;
var zip_flags;
var zip_flag_bit;
var zip_opt_len;
var zip_static_len;
var zip_deflate_data;
var zip_deflate_pos;

/* objects (deflate) */

function zip_DeflateCT() {
    this.fc = 0; // frequency count or bit string
    this.dl = 0; // father node in Huffman tree or length of bit string
}

function zip_DeflateTreeDesc() {
    this.dyn_tree = null;	// the dynamic tree
    this.static_tree = null;	// corresponding static tree or NULL
    this.extra_bits = null;	// extra bits for each code or NULL
    this.extra_base = 0;	// base index for extra_bits
    this.elems = 0;		// max number of elements in the tree
    this.max_length = 0;	// max bit length for the codes
    this.max_code = 0;		// largest code with non zero frequency
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function zip_DeflateConfiguration(a, b, c, d) {
    this.good_length = a; // reduce lazy search above this match length
    this.max_lazy = b;    // do not perform lazy search above this match length
    this.nice_length = c; // quit search above this match length
    this.max_chain = d;
}

function zip_DeflateBuffer() {
    this.next = null;
    this.len = 0;
    this.ptr = new Array(zip_OUTBUFSIZ);
    this.off = 0;
}

/* constant tables */
var zip_extra_lbits = [
    0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];
var zip_extra_dbits = [
    0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];
var zip_extra_blbits = [
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];
var zip_bl_order = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
var zip_configuration_table = [
	new zip_DeflateConfiguration(0,    0,   0,    0),
	new zip_DeflateConfiguration(4,    4,   8,    4),
	new zip_DeflateConfiguration(4,    5,  16,    8),
	new zip_DeflateConfiguration(4,    6,  32,   32),
	new zip_DeflateConfiguration(4,    4,  16,   16),
	new zip_DeflateConfiguration(8,   16,  32,   32),
	new zip_DeflateConfiguration(8,   16, 128,  128),
	new zip_DeflateConfiguration(8,   32, 128,  256),
	new zip_DeflateConfiguration(32, 128, 258, 1024),
	new zip_DeflateConfiguration(32, 258, 258, 4096)];


/* routines (deflate) */

function zip_deflate_start(level) {
    var i;

    if(!level)
	level = zip_DEFAULT_LEVEL;
    else if(level < 1)
	level = 1;
    else if(level > 9)
	level = 9;

    zip_compr_level = level;
    zip_initflag = false;
    zip_eofile = false;
    if(zip_outbuf != null)
	return;

    zip_free_queue = zip_qhead = zip_qtail = null;
    zip_outbuf = new Array(zip_OUTBUFSIZ);
    zip_window = new Array(zip_window_size);
    zip_d_buf = new Array(zip_DIST_BUFSIZE);
    zip_l_buf = new Array(zip_INBUFSIZ + zip_INBUF_EXTRA);
    zip_prev = new Array(1 << zip_BITS);
    zip_dyn_ltree = new Array(zip_HEAP_SIZE);
    for(i = 0; i < zip_HEAP_SIZE; i++)
	zip_dyn_ltree[i] = new zip_DeflateCT();
    zip_dyn_dtree = new Array(2*zip_D_CODES+1);
    for(i = 0; i < 2*zip_D_CODES+1; i++)
	zip_dyn_dtree[i] = new zip_DeflateCT();
    zip_static_ltree = new Array(zip_L_CODES+2);
    for(i = 0; i < zip_L_CODES+2; i++)
	zip_static_ltree[i] = new zip_DeflateCT();
    zip_static_dtree = new Array(zip_D_CODES);
    for(i = 0; i < zip_D_CODES; i++)
	zip_static_dtree[i] = new zip_DeflateCT();
    zip_bl_tree = new Array(2*zip_BL_CODES+1);
    for(i = 0; i < 2*zip_BL_CODES+1; i++)
	zip_bl_tree[i] = new zip_DeflateCT();
    zip_l_desc = new zip_DeflateTreeDesc();
    zip_d_desc = new zip_DeflateTreeDesc();
    zip_bl_desc = new zip_DeflateTreeDesc();
    zip_bl_count = new Array(zip_MAX_BITS+1);
    zip_heap = new Array(2*zip_L_CODES+1);
    zip_depth = new Array(2*zip_L_CODES+1);
    zip_length_code = new Array(zip_MAX_MATCH-zip_MIN_MATCH+1);
    zip_dist_code = new Array(512);
    zip_base_length = new Array(zip_LENGTH_CODES);
    zip_base_dist = new Array(zip_D_CODES);
    zip_flag_buf = new Array(parseInt(zip_LIT_BUFSIZE / 8));
}

function zip_deflate_end() {
    zip_free_queue = zip_qhead = zip_qtail = null;
    zip_outbuf = null;
    zip_window = null;
    zip_d_buf = null;
    zip_l_buf = null;
    zip_prev = null;
    zip_dyn_ltree = null;
    zip_dyn_dtree = null;
    zip_static_ltree = null;
    zip_static_dtree = null;
    zip_bl_tree = null;
    zip_l_desc = null;
    zip_d_desc = null;
    zip_bl_desc = null;
    zip_bl_count = null;
    zip_heap = null;
    zip_depth = null;
    zip_length_code = null;
    zip_dist_code = null;
    zip_base_length = null;
    zip_base_dist = null;
    zip_flag_buf = null;
}

function zip_reuse_queue(p) {
    p.next = zip_free_queue;
    zip_free_queue = p;
}

function zip_new_queue() {
    var p;

    if(zip_free_queue != null)
    {
	p = zip_free_queue;
	zip_free_queue = zip_free_queue.next;
    }
    else
	p = new zip_DeflateBuffer();
    p.next = null;
    p.len = p.off = 0;

    return p;
}

function zip_head1(i) {
    return zip_prev[zip_WSIZE + i];
}

function zip_head2(i, val) {
    return zip_prev[zip_WSIZE + i] = val;
}

/* put_byte is used for the compressed output, put_ubyte for the
 * uncompressed output. However unlzw() uses window for its
 * suffix table instead of its output buffer, so it does not use put_ubyte
 * (to be cleaned up).
 */
function zip_put_byte(c) {
    zip_outbuf[zip_outoff + zip_outcnt++] = c;
    if(zip_outoff + zip_outcnt == zip_OUTBUFSIZ)
	zip_qoutbuf();
}

/* Output a 16 bit value, lsb first */
function zip_put_short(w) {
    w &= 0xffff;
    if(zip_outoff + zip_outcnt < zip_OUTBUFSIZ - 2) {
	zip_outbuf[zip_outoff + zip_outcnt++] = (w & 0xff);
	zip_outbuf[zip_outoff + zip_outcnt++] = (w >>> 8);
    } else {
	zip_put_byte(w & 0xff);
	zip_put_byte(w >>> 8);
    }
}

/* ==========================================================================
 * Insert string s in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of s are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
function zip_INSERT_STRING() {
    zip_ins_h = ((zip_ins_h << zip_H_SHIFT)
		 ^ (zip_window[zip_strstart + zip_MIN_MATCH - 1] & 0xff))
	& zip_HASH_MASK;
    zip_hash_head = zip_head1(zip_ins_h);
    zip_prev[zip_strstart & zip_WMASK] = zip_hash_head;
    zip_head2(zip_ins_h, zip_strstart);
}

/* Send a code of the given tree. c and tree must not have side effects */
function zip_SEND_CODE(c, tree) {
    zip_send_bits(tree[c].fc, tree[c].dl);
}

/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. dist_code[256] and dist_code[257] are never
 * used.
 */
function zip_D_CODE(dist) {
    return (dist < 256 ? zip_dist_code[dist]
	    : zip_dist_code[256 + (dist>>7)]) & 0xff;
}

/* ==========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function zip_SMALLER(tree, n, m) {
    return tree[n].fc < tree[m].fc ||
      (tree[n].fc == tree[m].fc && zip_depth[n] <= zip_depth[m]);
}

/* ==========================================================================
 * read string data
 */
function zip_read_buff(buff, offset, n) {
    var i;
    for(i = 0; i < n && zip_deflate_pos < zip_deflate_data.length; i++)
	buff[offset + i] =
	    zip_deflate_data.charCodeAt(zip_deflate_pos++) & 0xff;
    return i;
}

/* ==========================================================================
 * Initialize the "longest match" routines for a new file
 */
function zip_lm_init() {
    var j;

    /* Initialize the hash table. */
    for(j = 0; j < zip_HASH_SIZE; j++)
//	zip_head2(j, zip_NIL);
	zip_prev[zip_WSIZE + j] = 0;
    /* prev will be initialized on the fly */

    /* Set the default configuration parameters:
     */
    zip_max_lazy_match = zip_configuration_table[zip_compr_level].max_lazy;
    zip_good_match     = zip_configuration_table[zip_compr_level].good_length;
    if(!zip_FULL_SEARCH)
	zip_nice_match = zip_configuration_table[zip_compr_level].nice_length;
    zip_max_chain_length = zip_configuration_table[zip_compr_level].max_chain;

    zip_strstart = 0;
    zip_block_start = 0;

    zip_lookahead = zip_read_buff(zip_window, 0, 2 * zip_WSIZE);
    if(zip_lookahead <= 0) {
	zip_eofile = true;
	zip_lookahead = 0;
	return;
    }
    zip_eofile = false;
    /* Make sure that we always have enough lookahead. This is important
     * if input comes from a device such as a tty.
     */
    while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)
	zip_fill_window();

    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is
     * not important since only literal bytes will be emitted.
     */
    zip_ins_h = 0;
    for(j = 0; j < zip_MIN_MATCH - 1; j++) {
//      UPDATE_HASH(ins_h, window[j]);
	zip_ins_h = ((zip_ins_h << zip_H_SHIFT) ^ (zip_window[j] & 0xff)) & zip_HASH_MASK;
    }
}

/* ==========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 */
function zip_longest_match(cur_match) {
    var chain_length = zip_max_chain_length; // max hash chain length
    var scanp = zip_strstart; // current string
    var matchp;		// matched string
    var len;		// length of current match
    var best_len = zip_prev_length;	// best match length so far

    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    var limit = (zip_strstart > zip_MAX_DIST ? zip_strstart - zip_MAX_DIST : zip_NIL);

    var strendp = zip_strstart + zip_MAX_MATCH;
    var scan_end1 = zip_window[scanp + best_len - 1];
    var scan_end  = zip_window[scanp + best_len];

    /* Do not waste too much time if we already have a good match: */
    if(zip_prev_length >= zip_good_match)
	chain_length >>= 2;

//  Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");

    do {
//    Assert(cur_match < encoder->strstart, "no future");
	matchp = cur_match;

	/* Skip to next match if the match length cannot increase
	    * or if the match length is less than 2:
	*/
	if(zip_window[matchp + best_len]	!= scan_end  ||
	   zip_window[matchp + best_len - 1]	!= scan_end1 ||
	   zip_window[matchp]			!= zip_window[scanp] ||
	   zip_window[++matchp]			!= zip_window[scanp + 1]) {
	    continue;
	}

	/* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
	scanp += 2;
	matchp++;

	/* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
	do {
	} while(zip_window[++scanp] == zip_window[++matchp] &&
		zip_window[++scanp] == zip_window[++matchp] &&
		zip_window[++scanp] == zip_window[++matchp] &&
		zip_window[++scanp] == zip_window[++matchp] &&
		zip_window[++scanp] == zip_window[++matchp] &&
		zip_window[++scanp] == zip_window[++matchp] &&
		zip_window[++scanp] == zip_window[++matchp] &&
		zip_window[++scanp] == zip_window[++matchp] &&
		scanp < strendp);

      len = zip_MAX_MATCH - (strendp - scanp);
      scanp = strendp - zip_MAX_MATCH;

      if(len > best_len) {
	  zip_match_start = cur_match;
	  best_len = len;
	  if(zip_FULL_SEARCH) {
	      if(len >= zip_MAX_MATCH) break;
	  } else {
	      if(len >= zip_nice_match) break;
	  }

	  scan_end1  = zip_window[scanp + best_len-1];
	  scan_end   = zip_window[scanp + best_len];
      }
    } while((cur_match = zip_prev[cur_match & zip_WMASK]) > limit
	    && --chain_length != 0);

    return best_len;
}

/* ==========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead, and sets eofile if end of input file.
 * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
 * OUT assertions: at least one byte has been read, or eofile is set;
 *    file reads are performed for at least two bytes (required for the
 *    translate_eol option).
 */
function zip_fill_window() {
    var n, m;

    // Amount of free space at the end of the window.
    var more = zip_window_size - zip_lookahead - zip_strstart;

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if(more == -1) {
	/* Very unlikely, but possible on 16 bit machine if strstart == 0
         * and lookahead == 1 (input done one byte at time)
         */
	more--;
    } else if(zip_strstart >= zip_WSIZE + zip_MAX_DIST) {
	/* By the IN assertion, the window is not empty so we can't confuse
         * more == 0 with more == 64K on a 16 bit machine.
         */
//	Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");

//	System.arraycopy(window, WSIZE, window, 0, WSIZE);
	for(n = 0; n < zip_WSIZE; n++)
	    zip_window[n] = zip_window[n + zip_WSIZE];
      
	zip_match_start -= zip_WSIZE;
	zip_strstart    -= zip_WSIZE; /* we now have strstart >= MAX_DIST: */
	zip_block_start -= zip_WSIZE;

	for(n = 0; n < zip_HASH_SIZE; n++) {
	    m = zip_head1(n);
	    zip_head2(n, m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);
	}
	for(n = 0; n < zip_WSIZE; n++) {
	    /* If n is not on any hash chain, prev[n] is garbage but
	     * its value will never be used.
	     */
	    m = zip_prev[n];
	    zip_prev[n] = (m >= zip_WSIZE ? m - zip_WSIZE : zip_NIL);
	}
	more += zip_WSIZE;
    }
    // At this point, more >= 2
    if(!zip_eofile) {
	n = zip_read_buff(zip_window, zip_strstart + zip_lookahead, more);
	if(n <= 0)
	    zip_eofile = true;
	else
	    zip_lookahead += n;
    }
}

/* ==========================================================================
 * Processes a new input file and return its compressed length. This
 * function does not perform lazy evaluationof matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function zip_deflate_fast() {
    while(zip_lookahead != 0 && zip_qhead == null) {
	var flush; // set if current block must be flushed

	/* Insert the string window[strstart .. strstart+2] in the
	 * dictionary, and set hash_head to the head of the hash chain:
	 */
	zip_INSERT_STRING();

	/* Find the longest match, discarding those <= prev_length.
	 * At this point we have always match_length < MIN_MATCH
	 */
	if(zip_hash_head != zip_NIL &&
	   zip_strstart - zip_hash_head <= zip_MAX_DIST) {
	    /* To simplify the code, we prevent matches with the string
	     * of window index 0 (in particular we have to avoid a match
	     * of the string with itself at the start of the input file).
	     */
	    zip_match_length = zip_longest_match(zip_hash_head);
	    /* longest_match() sets match_start */
	    if(zip_match_length > zip_lookahead)
		zip_match_length = zip_lookahead;
	}
	if(zip_match_length >= zip_MIN_MATCH) {
//	    check_match(strstart, match_start, match_length);

	    flush = zip_ct_tally(zip_strstart - zip_match_start,
				 zip_match_length - zip_MIN_MATCH);
	    zip_lookahead -= zip_match_length;

	    /* Insert new strings in the hash table only if the match length
	     * is not too large. This saves time but degrades compression.
	     */
	    if(zip_match_length <= zip_max_lazy_match) {
		zip_match_length--; // string at strstart already in hash table
		do {
		    zip_strstart++;
		    zip_INSERT_STRING();
		    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
		     * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
		     * these bytes are garbage, but it does not matter since
		     * the next lookahead bytes will be emitted as literals.
		     */
		} while(--zip_match_length != 0);
		zip_strstart++;
	    } else {
		zip_strstart += zip_match_length;
		zip_match_length = 0;
		zip_ins_h = zip_window[zip_strstart] & 0xff;
//		UPDATE_HASH(ins_h, window[strstart + 1]);
		zip_ins_h = ((zip_ins_h<<zip_H_SHIFT) ^ (zip_window[zip_strstart + 1] & 0xff)) & zip_HASH_MASK;

//#if MIN_MATCH != 3
//		Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif

	    }
	} else {
	    /* No match, output a literal byte */
	    flush = zip_ct_tally(0, zip_window[zip_strstart] & 0xff);
	    zip_lookahead--;
	    zip_strstart++;
	}
	if(flush) {
	    zip_flush_block(0);
	    zip_block_start = zip_strstart;
	}

	/* Make sure that we always have enough lookahead, except
	 * at the end of the input file. We need MAX_MATCH bytes
	 * for the next match, plus MIN_MATCH bytes to insert the
	 * string following the next match.
	 */
	while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)
	    zip_fill_window();
    }
}

function zip_deflate_better() {
    /* Process the input block. */
    while(zip_lookahead != 0 && zip_qhead == null) {
	/* Insert the string window[strstart .. strstart+2] in the
	 * dictionary, and set hash_head to the head of the hash chain:
	 */
	zip_INSERT_STRING();

	/* Find the longest match, discarding those <= prev_length.
	 */
	zip_prev_length = zip_match_length;
	zip_prev_match = zip_match_start;
	zip_match_length = zip_MIN_MATCH - 1;

	if(zip_hash_head != zip_NIL &&
	   zip_prev_length < zip_max_lazy_match &&
	   zip_strstart - zip_hash_head <= zip_MAX_DIST) {
	    /* To simplify the code, we prevent matches with the string
	     * of window index 0 (in particular we have to avoid a match
	     * of the string with itself at the start of the input file).
	     */
	    zip_match_length = zip_longest_match(zip_hash_head);
	    /* longest_match() sets match_start */
	    if(zip_match_length > zip_lookahead)
		zip_match_length = zip_lookahead;

	    /* Ignore a length 3 match if it is too distant: */
	    if(zip_match_length == zip_MIN_MATCH &&
	       zip_strstart - zip_match_start > zip_TOO_FAR) {
		/* If prev_match is also MIN_MATCH, match_start is garbage
		 * but we will ignore the current match anyway.
		 */
		zip_match_length--;
	    }
	}
	/* If there was a match at the previous step and the current
	 * match is not better, output the previous match:
	 */
	if(zip_prev_length >= zip_MIN_MATCH &&
	   zip_match_length <= zip_prev_length) {
	    var flush; // set if current block must be flushed

//	    check_match(strstart - 1, prev_match, prev_length);
	    flush = zip_ct_tally(zip_strstart - 1 - zip_prev_match,
				 zip_prev_length - zip_MIN_MATCH);

	    /* Insert in hash table all strings up to the end of the match.
	     * strstart-1 and strstart are already inserted.
	     */
	    zip_lookahead -= zip_prev_length - 1;
	    zip_prev_length -= 2;
	    do {
		zip_strstart++;
		zip_INSERT_STRING();
		/* strstart never exceeds WSIZE-MAX_MATCH, so there are
		 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
		 * these bytes are garbage, but it does not matter since the
		 * next lookahead bytes will always be emitted as literals.
		 */
	    } while(--zip_prev_length != 0);
	    zip_match_available = 0;
	    zip_match_length = zip_MIN_MATCH - 1;
	    zip_strstart++;
	    if(flush) {
		zip_flush_block(0);
		zip_block_start = zip_strstart;
	    }
	} else if(zip_match_available != 0) {
	    /* If there was no match at the previous position, output a
	     * single literal. If there was a match but the current match
	     * is longer, truncate the previous match to a single literal.
	     */
	    if(zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff)) {
		zip_flush_block(0);
		zip_block_start = zip_strstart;
	    }
	    zip_strstart++;
	    zip_lookahead--;
	} else {
	    /* There is no previous match to compare with, wait for
	     * the next step to decide.
	     */
	    zip_match_available = 1;
	    zip_strstart++;
	    zip_lookahead--;
	}

	/* Make sure that we always have enough lookahead, except
	 * at the end of the input file. We need MAX_MATCH bytes
	 * for the next match, plus MIN_MATCH bytes to insert the
	 * string following the next match.
	 */
	while(zip_lookahead < zip_MIN_LOOKAHEAD && !zip_eofile)
	    zip_fill_window();
    }
}

function zip_init_deflate() {
    if(zip_eofile)
	return;
    zip_bi_buf = 0;
    zip_bi_valid = 0;
    zip_ct_init();
    zip_lm_init();

    zip_qhead = null;
    zip_outcnt = 0;
    zip_outoff = 0;

    if(zip_compr_level <= 3)
    {
	zip_prev_length = zip_MIN_MATCH - 1;
	zip_match_length = 0;
    }
    else
    {
	zip_match_length = zip_MIN_MATCH - 1;
	zip_match_available = 0;
    }

    zip_complete = false;
}

/* ==========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function zip_deflate_internal(buff, off, buff_size) {
    var n;

    if(!zip_initflag)
    {
	zip_init_deflate();
	zip_initflag = true;
	if(zip_lookahead == 0) { // empty
	    zip_complete = true;
	    return 0;
	}
    }

    if((n = zip_qcopy(buff, off, buff_size)) == buff_size)
	return buff_size;

    if(zip_complete)
	return n;

    if(zip_compr_level <= 3) // optimized for speed
	zip_deflate_fast();
    else
	zip_deflate_better();
    if(zip_lookahead == 0) {
	if(zip_match_available != 0)
	    zip_ct_tally(0, zip_window[zip_strstart - 1] & 0xff);
	zip_flush_block(1);
	zip_complete = true;
    }
    return n + zip_qcopy(buff, n + off, buff_size - n);
}

function zip_qcopy(buff, off, buff_size) {
    var n, i, j;

    n = 0;
    while(zip_qhead != null && n < buff_size)
    {
	i = buff_size - n;
	if(i > zip_qhead.len)
	    i = zip_qhead.len;
//      System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);
	for(j = 0; j < i; j++)
	    buff[off + n + j] = zip_qhead.ptr[zip_qhead.off + j];
	
	zip_qhead.off += i;
	zip_qhead.len -= i;
	n += i;
	if(zip_qhead.len == 0) {
	    var p;
	    p = zip_qhead;
	    zip_qhead = zip_qhead.next;
	    zip_reuse_queue(p);
	}
    }

    if(n == buff_size)
	return n;

    if(zip_outoff < zip_outcnt) {
	i = buff_size - n;
	if(i > zip_outcnt - zip_outoff)
	    i = zip_outcnt - zip_outoff;
	// System.arraycopy(outbuf, outoff, buff, off + n, i);
	for(j = 0; j < i; j++)
	    buff[off + n + j] = zip_outbuf[zip_outoff + j];
	zip_outoff += i;
	n += i;
	if(zip_outcnt == zip_outoff)
	    zip_outcnt = zip_outoff = 0;
    }
    return n;
}

/* ==========================================================================
 * Allocate the match buffer, initialize the various tables and save the
 * location of the internal file attribute (ascii/binary) and method
 * (DEFLATE/STORE).
 */
function zip_ct_init() {
    var n;	// iterates over tree elements
    var bits;	// bit counter
    var length;	// length value
    var code;	// code value
    var dist;	// distance index

    if(zip_static_dtree[0].dl != 0) return; // ct_init already called

    zip_l_desc.dyn_tree		= zip_dyn_ltree;
    zip_l_desc.static_tree	= zip_static_ltree;
    zip_l_desc.extra_bits	= zip_extra_lbits;
    zip_l_desc.extra_base	= zip_LITERALS + 1;
    zip_l_desc.elems		= zip_L_CODES;
    zip_l_desc.max_length	= zip_MAX_BITS;
    zip_l_desc.max_code		= 0;

    zip_d_desc.dyn_tree		= zip_dyn_dtree;
    zip_d_desc.static_tree	= zip_static_dtree;
    zip_d_desc.extra_bits	= zip_extra_dbits;
    zip_d_desc.extra_base	= 0;
    zip_d_desc.elems		= zip_D_CODES;
    zip_d_desc.max_length	= zip_MAX_BITS;
    zip_d_desc.max_code		= 0;

    zip_bl_desc.dyn_tree	= zip_bl_tree;
    zip_bl_desc.static_tree	= null;
    zip_bl_desc.extra_bits	= zip_extra_blbits;
    zip_bl_desc.extra_base	= 0;
    zip_bl_desc.elems		= zip_BL_CODES;
    zip_bl_desc.max_length	= zip_MAX_BL_BITS;
    zip_bl_desc.max_code	= 0;

    // Initialize the mapping length (0..255) -> length code (0..28)
    length = 0;
    for(code = 0; code < zip_LENGTH_CODES-1; code++) {
	zip_base_length[code] = length;
	for(n = 0; n < (1<<zip_extra_lbits[code]); n++)
	    zip_length_code[length++] = code;
    }
    // Assert (length == 256, "ct_init: length != 256");

    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    zip_length_code[length-1] = code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for(code = 0 ; code < 16; code++) {
	zip_base_dist[code] = dist;
	for(n = 0; n < (1<<zip_extra_dbits[code]); n++) {
	    zip_dist_code[dist++] = code;
	}
    }
    // Assert (dist == 256, "ct_init: dist != 256");
    dist >>= 7; // from now on, all distances are divided by 128
    for( ; code < zip_D_CODES; code++) {
	zip_base_dist[code] = dist << 7;
	for(n = 0; n < (1<<(zip_extra_dbits[code]-7)); n++)
	    zip_dist_code[256 + dist++] = code;
    }
    // Assert (dist == 256, "ct_init: 256+dist != 512");

    // Construct the codes of the static literal tree
    for(bits = 0; bits <= zip_MAX_BITS; bits++)
	zip_bl_count[bits] = 0;
    n = 0;
    while(n <= 143) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }
    while(n <= 255) { zip_static_ltree[n++].dl = 9; zip_bl_count[9]++; }
    while(n <= 279) { zip_static_ltree[n++].dl = 7; zip_bl_count[7]++; }
    while(n <= 287) { zip_static_ltree[n++].dl = 8; zip_bl_count[8]++; }
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    zip_gen_codes(zip_static_ltree, zip_L_CODES + 1);

    /* The static distance tree is trivial: */
    for(n = 0; n < zip_D_CODES; n++) {
	zip_static_dtree[n].dl = 5;
	zip_static_dtree[n].fc = zip_bi_reverse(n, 5);
    }

    // Initialize the first block of the first file:
    zip_init_block();
}

/* ==========================================================================
 * Initialize a new block.
 */
function zip_init_block() {
    var n; // iterates over tree elements

    // Initialize the trees.
    for(n = 0; n < zip_L_CODES;  n++) zip_dyn_ltree[n].fc = 0;
    for(n = 0; n < zip_D_CODES;  n++) zip_dyn_dtree[n].fc = 0;
    for(n = 0; n < zip_BL_CODES; n++) zip_bl_tree[n].fc = 0;

    zip_dyn_ltree[zip_END_BLOCK].fc = 1;
    zip_opt_len = zip_static_len = 0;
    zip_last_lit = zip_last_dist = zip_last_flags = 0;
    zip_flags = 0;
    zip_flag_bit = 1;
}

/* ==========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function zip_pqdownheap(
    tree,	// the tree to restore
    k) {	// node to move down
    var v = zip_heap[k];
    var j = k << 1;	// left son of k

    while(j <= zip_heap_len) {
	// Set j to the smallest of the two sons:
	if(j < zip_heap_len &&
	   zip_SMALLER(tree, zip_heap[j + 1], zip_heap[j]))
	    j++;

	// Exit if v is smaller than both sons
	if(zip_SMALLER(tree, v, zip_heap[j]))
	    break;

	// Exchange v with the smallest son
	zip_heap[k] = zip_heap[j];
	k = j;

	// And continue down the tree, setting j to the left son of k
	j <<= 1;
    }
    zip_heap[k] = v;
}

/* ==========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function zip_gen_bitlen(desc) { // the tree descriptor
    var tree		= desc.dyn_tree;
    var extra		= desc.extra_bits;
    var base		= desc.extra_base;
    var max_code	= desc.max_code;
    var max_length	= desc.max_length;
    var stree		= desc.static_tree;
    var h;		// heap index
    var n, m;		// iterate over the tree elements
    var bits;		// bit length
    var xbits;		// extra bits
    var f;		// frequency
    var overflow = 0;	// number of elements with bit length too large

    for(bits = 0; bits <= zip_MAX_BITS; bits++)
	zip_bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[zip_heap[zip_heap_max]].dl = 0; // root of the heap

    for(h = zip_heap_max + 1; h < zip_HEAP_SIZE; h++) {
	n = zip_heap[h];
	bits = tree[tree[n].dl].dl + 1;
	if(bits > max_length) {
	    bits = max_length;
	    overflow++;
	}
	tree[n].dl = bits;
	// We overwrite tree[n].dl which is no longer needed

	if(n > max_code)
	    continue; // not a leaf node

	zip_bl_count[bits]++;
	xbits = 0;
	if(n >= base)
	    xbits = extra[n - base];
	f = tree[n].fc;
	zip_opt_len += f * (bits + xbits);
	if(stree != null)
	    zip_static_len += f * (stree[n].dl + xbits);
    }
    if(overflow == 0)
	return;

    // This happens for example on obj2 and pic of the Calgary corpus

    // Find the first bit length which could increase:
    do {
	bits = max_length - 1;
	while(zip_bl_count[bits] == 0)
	    bits--;
	zip_bl_count[bits]--;		// move one leaf down the tree
	zip_bl_count[bits + 1] += 2;	// move one overflow item as its brother
	zip_bl_count[max_length]--;
	/* The brother of the overflow item also moves one step up,
	 * but this does not affect bl_count[max_length]
	 */
	overflow -= 2;
    } while(overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for(bits = max_length; bits != 0; bits--) {
	n = zip_bl_count[bits];
	while(n != 0) {
	    m = zip_heap[--h];
	    if(m > max_code)
		continue;
	    if(tree[m].dl != bits) {
		zip_opt_len += (bits - tree[m].dl) * tree[m].fc;
		tree[m].fc = bits;
	    }
	    n--;
	}
    }
}

  /* ==========================================================================
   * Generate the codes for a given tree and bit counts (which need not be
   * optimal).
   * IN assertion: the array bl_count contains the bit length statistics for
   * the given tree and the field len is set for all tree elements.
   * OUT assertion: the field code is set for all tree elements of non
   *     zero code length.
   */
function zip_gen_codes(tree,	// the tree to decorate
		   max_code) {	// largest code with non zero frequency
    var next_code = new Array(zip_MAX_BITS+1); // next code value for each bit length
    var code = 0;		// running code value
    var bits;			// bit index
    var n;			// code index

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for(bits = 1; bits <= zip_MAX_BITS; bits++) {
	code = ((code + zip_bl_count[bits-1]) << 1);
	next_code[bits] = code;
    }

    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
//    Assert (code + encoder->bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
//	    "inconsistent bit counts");
//    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for(n = 0; n <= max_code; n++) {
	var len = tree[n].dl;
	if(len == 0)
	    continue;
	// Now reverse the bits
	tree[n].fc = zip_bi_reverse(next_code[len]++, len);

//      Tracec(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
//	  n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));
    }
}

/* ==========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function zip_build_tree(desc) { // the tree descriptor
    var tree	= desc.dyn_tree;
    var stree	= desc.static_tree;
    var elems	= desc.elems;
    var n, m;		// iterate over heap elements
    var max_code = -1;	// largest code with non zero frequency
    var node = elems;	// next internal node of the tree

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    zip_heap_len = 0;
    zip_heap_max = zip_HEAP_SIZE;

    for(n = 0; n < elems; n++) {
	if(tree[n].fc != 0) {
	    zip_heap[++zip_heap_len] = max_code = n;
	    zip_depth[n] = 0;
	} else
	    tree[n].dl = 0;
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while(zip_heap_len < 2) {
	var xnew = zip_heap[++zip_heap_len] = (max_code < 2 ? ++max_code : 0);
	tree[xnew].fc = 1;
	zip_depth[xnew] = 0;
	zip_opt_len--;
	if(stree != null)
	    zip_static_len -= stree[xnew].dl;
	// new is 0 or 1 so it does not have extra bits
    }
    desc.max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for(n = zip_heap_len >> 1; n >= 1; n--)
	zip_pqdownheap(tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    do {
	n = zip_heap[zip_SMALLEST];
	zip_heap[zip_SMALLEST] = zip_heap[zip_heap_len--];
	zip_pqdownheap(tree, zip_SMALLEST);

	m = zip_heap[zip_SMALLEST];  // m = node of next least frequency

	// keep the nodes sorted by frequency
	zip_heap[--zip_heap_max] = n;
	zip_heap[--zip_heap_max] = m;

	// Create a new node father of n and m
	tree[node].fc = tree[n].fc + tree[m].fc;
//	depth[node] = (char)(MAX(depth[n], depth[m]) + 1);
	if(zip_depth[n] > zip_depth[m] + 1)
	    zip_depth[node] = zip_depth[n];
	else
	    zip_depth[node] = zip_depth[m] + 1;
	tree[n].dl = tree[m].dl = node;

	// and insert the new node in the heap
	zip_heap[zip_SMALLEST] = node++;
	zip_pqdownheap(tree, zip_SMALLEST);

    } while(zip_heap_len >= 2);

    zip_heap[--zip_heap_max] = zip_heap[zip_SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    zip_gen_bitlen(desc);

    // The field len is now set, we can generate the bit codes
    zip_gen_codes(tree, max_code);
}

/* ==========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree. Updates opt_len to take into account the repeat
 * counts. (The contribution of the bit length codes will be added later
 * during the construction of bl_tree.)
 */
function zip_scan_tree(tree,// the tree to be scanned
		       max_code) {  // and its largest code of non zero frequency
    var n;			// iterates over all tree elements
    var prevlen = -1;		// last emitted length
    var curlen;			// length of current code
    var nextlen = tree[0].dl;	// length of next code
    var count = 0;		// repeat count of the current code
    var max_count = 7;		// max repeat count
    var min_count = 4;		// min repeat count

    if(nextlen == 0) {
	max_count = 138;
	min_count = 3;
    }
    tree[max_code + 1].dl = 0xffff; // guard

    for(n = 0; n <= max_code; n++) {
	curlen = nextlen;
	nextlen = tree[n + 1].dl;
	if(++count < max_count && curlen == nextlen)
	    continue;
	else if(count < min_count)
	    zip_bl_tree[curlen].fc += count;
	else if(curlen != 0) {
	    if(curlen != prevlen)
		zip_bl_tree[curlen].fc++;
	    zip_bl_tree[zip_REP_3_6].fc++;
	} else if(count <= 10)
	    zip_bl_tree[zip_REPZ_3_10].fc++;
	else
	    zip_bl_tree[zip_REPZ_11_138].fc++;
	count = 0; prevlen = curlen;
	if(nextlen == 0) {
	    max_count = 138;
	    min_count = 3;
	} else if(curlen == nextlen) {
	    max_count = 6;
	    min_count = 3;
	} else {
	    max_count = 7;
	    min_count = 4;
	}
    }
}

  /* ==========================================================================
   * Send a literal or distance tree in compressed form, using the codes in
   * bl_tree.
   */
function zip_send_tree(tree, // the tree to be scanned
		   max_code) { // and its largest code of non zero frequency
    var n;			// iterates over all tree elements
    var prevlen = -1;		// last emitted length
    var curlen;			// length of current code
    var nextlen = tree[0].dl;	// length of next code
    var count = 0;		// repeat count of the current code
    var max_count = 7;		// max repeat count
    var min_count = 4;		// min repeat count

    /* tree[max_code+1].dl = -1; */  /* guard already set */
    if(nextlen == 0) {
      max_count = 138;
      min_count = 3;
    }

    for(n = 0; n <= max_code; n++) {
	curlen = nextlen;
	nextlen = tree[n+1].dl;
	if(++count < max_count && curlen == nextlen) {
	    continue;
	} else if(count < min_count) {
	    do { zip_SEND_CODE(curlen, zip_bl_tree); } while(--count != 0);
	} else if(curlen != 0) {
	    if(curlen != prevlen) {
		zip_SEND_CODE(curlen, zip_bl_tree);
		count--;
	    }
	    // Assert(count >= 3 && count <= 6, " 3_6?");
	    zip_SEND_CODE(zip_REP_3_6, zip_bl_tree);
	    zip_send_bits(count - 3, 2);
	} else if(count <= 10) {
	    zip_SEND_CODE(zip_REPZ_3_10, zip_bl_tree);
	    zip_send_bits(count-3, 3);
	} else {
	    zip_SEND_CODE(zip_REPZ_11_138, zip_bl_tree);
	    zip_send_bits(count-11, 7);
	}
	count = 0;
	prevlen = curlen;
	if(nextlen == 0) {
	    max_count = 138;
	    min_count = 3;
	} else if(curlen == nextlen) {
	    max_count = 6;
	    min_count = 3;
	} else {
	    max_count = 7;
	    min_count = 4;
	}
    }
}

/* ==========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function zip_build_bl_tree() {
    var max_blindex;  // index of last bit length code of non zero freq

    // Determine the bit length frequencies for literal and distance trees
    zip_scan_tree(zip_dyn_ltree, zip_l_desc.max_code);
    zip_scan_tree(zip_dyn_dtree, zip_d_desc.max_code);

    // Build the bit length tree:
    zip_build_tree(zip_bl_desc);
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for(max_blindex = zip_BL_CODES-1; max_blindex >= 3; max_blindex--) {
	if(zip_bl_tree[zip_bl_order[max_blindex]].dl != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    zip_opt_len += 3*(max_blindex+1) + 5+5+4;
//    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
//	    encoder->opt_len, encoder->static_len));

    return max_blindex;
}

/* ==========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function zip_send_all_trees(lcodes, dcodes, blcodes) { // number of codes for each tree
    var rank; // index in bl_order

//    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
//    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
//	    "too many codes");
//    Tracev((stderr, "\nbl counts: "));
    zip_send_bits(lcodes-257, 5); // not +255 as stated in appnote.txt
    zip_send_bits(dcodes-1,   5);
    zip_send_bits(blcodes-4,  4); // not -3 as stated in appnote.txt
    for(rank = 0; rank < blcodes; rank++) {
//      Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
	zip_send_bits(zip_bl_tree[zip_bl_order[rank]].dl, 3);
    }

    // send the literal tree
    zip_send_tree(zip_dyn_ltree,lcodes-1);

    // send the distance tree
    zip_send_tree(zip_dyn_dtree,dcodes-1);
}

/* ==========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function zip_flush_block(eof) { // true if this is the last block for a file
    var opt_lenb, static_lenb; // opt_len and static_len in bytes
    var max_blindex;	// index of last bit length code of non zero freq
    var stored_len;	// length of input block

    stored_len = zip_strstart - zip_block_start;
    zip_flag_buf[zip_last_flags] = zip_flags; // Save the flags for the last 8 items

    // Construct the literal and distance trees
    zip_build_tree(zip_l_desc);
//    Tracev((stderr, "\nlit data: dyn %ld, stat %ld",
//	    encoder->opt_len, encoder->static_len));

    zip_build_tree(zip_d_desc);
//    Tracev((stderr, "\ndist data: dyn %ld, stat %ld",
//	    encoder->opt_len, encoder->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = zip_build_bl_tree();

    // Determine the best encoding. Compute first the block length in bytes
    opt_lenb	= (zip_opt_len   +3+7)>>3;
    static_lenb = (zip_static_len+3+7)>>3;

//    Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ",
//	   opt_lenb, encoder->opt_len,
//	   static_lenb, encoder->static_len, stored_len,
//	   encoder->last_lit, encoder->last_dist));

    if(static_lenb <= opt_lenb)
	opt_lenb = static_lenb;
    if(stored_len + 4 <= opt_lenb // 4: two words for the lengths
       && zip_block_start >= 0) {
	var i;

	/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	 * Otherwise we can't have processed more than WSIZE input bytes since
	 * the last block flush, because compression would have been
	 * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	 * transform a block into a stored block.
	 */
	zip_send_bits((zip_STORED_BLOCK<<1)+eof, 3);  /* send block type */
	zip_bi_windup();		 /* align on byte boundary */
	zip_put_short(stored_len);
	zip_put_short(~stored_len);

      // copy block
/*
      p = &window[block_start];
      for(i = 0; i < stored_len; i++)
	put_byte(p[i]);
*/
	for(i = 0; i < stored_len; i++)
	    zip_put_byte(zip_window[zip_block_start + i]);

    } else if(static_lenb == opt_lenb) {
	zip_send_bits((zip_STATIC_TREES<<1)+eof, 3);
	zip_compress_block(zip_static_ltree, zip_static_dtree);
    } else {
	zip_send_bits((zip_DYN_TREES<<1)+eof, 3);
	zip_send_all_trees(zip_l_desc.max_code+1,
			   zip_d_desc.max_code+1,
			   max_blindex+1);
	zip_compress_block(zip_dyn_ltree, zip_dyn_dtree);
    }

    zip_init_block();

    if(eof != 0)
	zip_bi_windup();
}

/* ==========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function zip_ct_tally(
	dist, // distance of matched string
	lc) { // match length-MIN_MATCH or unmatched char (if dist==0)
    zip_l_buf[zip_last_lit++] = lc;
    if(dist == 0) {
	// lc is the unmatched char
	zip_dyn_ltree[lc].fc++;
    } else {
	// Here, lc is the match length - MIN_MATCH
	dist--;		    // dist = match distance - 1
//      Assert((ush)dist < (ush)MAX_DIST &&
//	     (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
//	     (ush)D_CODE(dist) < (ush)D_CODES,  "ct_tally: bad match");

	zip_dyn_ltree[zip_length_code[lc]+zip_LITERALS+1].fc++;
	zip_dyn_dtree[zip_D_CODE(dist)].fc++;

	zip_d_buf[zip_last_dist++] = dist;
	zip_flags |= zip_flag_bit;
    }
    zip_flag_bit <<= 1;

    // Output the flags if they fill a byte
    if((zip_last_lit & 7) == 0) {
	zip_flag_buf[zip_last_flags++] = zip_flags;
	zip_flags = 0;
	zip_flag_bit = 1;
    }
    // Try to guess if it is profitable to stop the current block here
    if(zip_compr_level > 2 && (zip_last_lit & 0xfff) == 0) {
	// Compute an upper bound for the compressed length
	var out_length = zip_last_lit * 8;
	var in_length = zip_strstart - zip_block_start;
	var dcode;

	for(dcode = 0; dcode < zip_D_CODES; dcode++) {
	    out_length += zip_dyn_dtree[dcode].fc * (5 + zip_extra_dbits[dcode]);
	}
	out_length >>= 3;
//      Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ",
//	     encoder->last_lit, encoder->last_dist, in_length, out_length,
//	     100L - out_length*100L/in_length));
	if(zip_last_dist < parseInt(zip_last_lit/2) &&
	   out_length < parseInt(in_length/2))
	    return true;
    }
    return (zip_last_lit == zip_LIT_BUFSIZE-1 ||
	    zip_last_dist == zip_DIST_BUFSIZE);
    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

  /* ==========================================================================
   * Send the block data compressed using the given Huffman trees
   */
function zip_compress_block(
	ltree,	// literal tree
	dtree) {	// distance tree
    var dist;		// distance of matched string
    var lc;		// match length or unmatched char (if dist == 0)
    var lx = 0;		// running index in l_buf
    var dx = 0;		// running index in d_buf
    var fx = 0;		// running index in flag_buf
    var flag = 0;	// current flags
    var code;		// the code to send
    var extra;		// number of extra bits to send

    if(zip_last_lit != 0) do {
	if((lx & 7) == 0)
	    flag = zip_flag_buf[fx++];
	lc = zip_l_buf[lx++] & 0xff;
	if((flag & 1) == 0) {
	    zip_SEND_CODE(lc, ltree); /* send a literal byte */
//	Tracecv(isgraph(lc), (stderr," '%c' ", lc));
	} else {
	    // Here, lc is the match length - MIN_MATCH
	    code = zip_length_code[lc];
	    zip_SEND_CODE(code+zip_LITERALS+1, ltree); // send the length code
	    extra = zip_extra_lbits[code];
	    if(extra != 0) {
		lc -= zip_base_length[code];
		zip_send_bits(lc, extra); // send the extra length bits
	    }
	    dist = zip_d_buf[dx++];
	    // Here, dist is the match distance - 1
	    code = zip_D_CODE(dist);
//	Assert (code < D_CODES, "bad d_code");

	    zip_SEND_CODE(code, dtree);	  // send the distance code
	    extra = zip_extra_dbits[code];
	    if(extra != 0) {
		dist -= zip_base_dist[code];
		zip_send_bits(dist, extra);   // send the extra distance bits
	    }
	} // literal or match pair ?
	flag >>= 1;
    } while(lx < zip_last_lit);

    zip_SEND_CODE(zip_END_BLOCK, ltree);
}

/* ==========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
var zip_Buf_size = 16; // bit size of bi_buf
function zip_send_bits(
	value,	// value to send
	length) {	// number of bits
    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if(zip_bi_valid > zip_Buf_size - length) {
	zip_bi_buf |= (value << zip_bi_valid);
	zip_put_short(zip_bi_buf);
	zip_bi_buf = (value >> (zip_Buf_size - zip_bi_valid));
	zip_bi_valid += length - zip_Buf_size;
    } else {
	zip_bi_buf |= value << zip_bi_valid;
	zip_bi_valid += length;
    }
}

/* ==========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function zip_bi_reverse(
	code,	// the value to invert
	len) {	// its bit length
    var res = 0;
    do {
	res |= code & 1;
	code >>= 1;
	res <<= 1;
    } while(--len > 0);
    return res >> 1;
}

/* ==========================================================================
 * Write out any remaining bits in an incomplete byte.
 */
function zip_bi_windup() {
    if(zip_bi_valid > 8) {
	zip_put_short(zip_bi_buf);
    } else if(zip_bi_valid > 0) {
	zip_put_byte(zip_bi_buf);
    }
    zip_bi_buf = 0;
    zip_bi_valid = 0;
}

function zip_qoutbuf() {
    if(zip_outcnt != 0) {
	var q, i;
	q = zip_new_queue();
	if(zip_qhead == null)
	    zip_qhead = zip_qtail = q;
	else
	    zip_qtail = zip_qtail.next = q;
	q.len = zip_outcnt - zip_outoff;
//      System.arraycopy(zip_outbuf, zip_outoff, q.ptr, 0, q.len);
	for(i = 0; i < q.len; i++)
	    q.ptr[i] = zip_outbuf[zip_outoff + i];
	zip_outcnt = zip_outoff = 0;
    }
}

return function deflate(str, level) {
    var i, j;

    zip_deflate_data = str;
    zip_deflate_pos = 0;
    if(typeof level == "undefined")
	level = zip_DEFAULT_LEVEL;
    zip_deflate_start(level);

    var buff = new Array(1024);
    var aout = [];
    while((i = zip_deflate_internal(buff, 0, buff.length)) > 0) {
	var cbuf = new Array(i);
	for(j = 0; j < i; j++){
	    cbuf[j] = String.fromCharCode(buff[j]);
	}
	aout[aout.length] = cbuf.join("");
    }
    zip_deflate_data = null; // G.C.
    return aout.join("");
};

})();

onmessage = function worker(m) {
  postMessage(deflate(m.data, 9));
};

onconnect = function sharedWorker(e) {
  var port = e.ports[0];
  port.onmessage = function(m) {
    port.postMessage(deflate(m.data, 9));
  };
};


function encode64(data) {
	r = "";
	for (i=0; i<data.length; i+=3) {
 		if (i+2==data.length) {
			r +=append3bytes(data.charCodeAt(i), data.charCodeAt(i+1), 0);
		} else if (i+1==data.length) {
			r += append3bytes(data.charCodeAt(i), 0, 0);
		} else {
			r += append3bytes(data.charCodeAt(i), data.charCodeAt(i+1),
				data.charCodeAt(i+2));
		}
	}
	return r;
}

function append3bytes(b1, b2, b3) {
	c1 = b1 >> 2;
	c2 = ((b1 & 0x3) << 4) | (b2 >> 4);
	c3 = ((b2 & 0xF) << 2) | (b3 >> 6);
	c4 = b3 & 0x3F;
	r = "";
	r += encode6bit(c1 & 0x3F);
	r += encode6bit(c2 & 0x3F);
	r += encode6bit(c3 & 0x3F);
	r += encode6bit(c4 & 0x3F);
	return r;
}

function encode6bit(b) {
	if (b < 10) {
 		return String.fromCharCode(48 + b);
	}
	b -= 10;
	if (b < 26) {
 		return String.fromCharCode(65 + b);
	}
	b -= 26;
	if (b < 26) {
 		return String.fromCharCode(97 + b);
	}
	b -= 26;
	if (b == 0) {
 		return '-';
	}
	if (b == 1) {
 		return '_';
	}
	return '?';
}

function compress(s) {
  //UTF8
  s = unescape(encodeURIComponent(s));
  src = "https://www.plantuml.com/plantuml/img/"+encode64(deflate(s, 9));
  // src = "http://www.plantuml.com/plantuml/png/"+encode64(deflate(s, 9));
  //src = "http://www.plantuml.com/plantuml/svg/"+encode64(deflate(s, 9));
  return src
}

function plantuml_url(s) {
  return compress(s)
}

function plantuml_url_for_open(s) {
  s = unescape(encodeURIComponent(s));
  src = "http://www.plantuml.com/plantuml/uml/"+encode64(deflate(s, 9));
  return src
}


//download.js v3.0, by dandavis; 2008-2014. [CCBY2] see http://danml.com/download.html for tests/usage
// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime
// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs
// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support

// data can be a string, Blob, File, or dataURL

		 
						 
						 
function download(data, strFileName, strMimeType) {
	
	var self = window, // this script is only for browsers anyway...
		u = "application/octet-stream", // this default mime also triggers iframe downloads
		m = strMimeType || u, 
		x = data,
		D = document,
		a = D.createElement("a"),
		z = function(a){return String(a);},
		
		
		B = self.Blob || self.MozBlob || self.WebKitBlob || z,
		BB = self.MSBlobBuilder || self.WebKitBlobBuilder || self.BlobBuilder,
		fn = strFileName || "download",
		blob, 
		b,
		ua,
		fr;

	//if(typeof B.bind === 'function' ){ B=B.bind(self); }
	
	if(String(this)==="true"){ //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
		x=[x, m];
		m=x[0];
		x=x[1]; 
	}
	
	
	
	//go ahead and download dataURLs right away
	if(String(x).match(/^data\:[\w+\-]+\/[\w+\-]+[,;]/)){
		return navigator.msSaveBlob ?  // IE10 can't do a[download], only Blobs:
			navigator.msSaveBlob(d2b(x), fn) : 
			saver(x) ; // everyone else can save dataURLs un-processed
	}//end if dataURL passed?
	
	try{
	
		blob = x instanceof B ? 
			x : 
			new B([x], {type: m}) ;
	}catch(y){
		if(BB){
			b = new BB();
			b.append([x]);
			blob = b.getBlob(m); // the blob
		}
		
	}
	
	
	
	function d2b(u) {
		var p= u.split(/[:;,]/),
		t= p[1],
		dec= p[2] == "base64" ? atob : decodeURIComponent,
		bin= dec(p.pop()),
		mx= bin.length,
		i= 0,
		uia= new Uint8Array(mx);

		for(i;i<mx;++i) uia[i]= bin.charCodeAt(i);

		return new B([uia], {type: t});
	 }
	  
	function saver(url, winMode){
		
		
		if ('download' in a) { //html5 A[download] 			
			a.href = url;
			a.setAttribute("download", fn);
			a.innerHTML = "downloading...";
			D.body.appendChild(a);
			setTimeout(function() {
				a.click();
				D.body.removeChild(a);
				if(winMode===true){setTimeout(function(){ self.URL.revokeObjectURL(a.href);}, 250 );}
			}, 66);
			return true;
		}
		
		//do iframe dataURL download (old ch+FF):
		var f = D.createElement("iframe");
		D.body.appendChild(f);
		if(!winMode){ // force a mime that will download:
			url="data:"+url.replace(/^data:([\w\/\-\+]+)/, u);
		}
		 
	
		f.src = url;
		setTimeout(function(){ D.body.removeChild(f); }, 333);
		
	}//end saver 
		

	if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)
		return navigator.msSaveBlob(blob, fn);
	} 	
	
	if(self.URL){ // simple fast and modern way using Blob and URL:
		saver(self.URL.createObjectURL(blob), true);
	}else{
		// handle non-Blob()+non-URL browsers:
		if(typeof blob === "string" || blob.constructor===z ){
			try{
				return saver( "data:" +  m   + ";base64,"  +  self.btoa(blob)  ); 
			}catch(y){
				return saver( "data:" +  m   + "," + encodeURIComponent(blob)  ); 
			}
		}
		
		// Blob but not URL:
		fr=new FileReader();
		fr.onload=function(e){
			saver(this.result); 
		};
		fr.readAsDataURL(blob);
	}	
	return true;
} /* end download() */



// function dispFile(contents) {
  // document.getElementById('import_content').innerHTML=contents
// }

function clickElem(elem) {
	// Thx user1601638 on Stack Overflow (6/6/2018 - https://stackoverflow.com/questions/13405129/javascript-create-and-save-file )
	var eventMouse = document.createEvent("MouseEvents")
	eventMouse.initMouseEvent("click", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null)
	elem.dispatchEvent(eventMouse)
}

function openFile(func) {
	readFile = function(e) {
		var file = e.target.files[0];
		if (!file) {
			return;
		}
		var reader = new FileReader();
		reader.onload = function(e) {
			var contents = e.target.result;
			fileInput.func(contents)
			document.body.removeChild(fileInput)
		}
		reader.readAsText(file)
	}
	fileInput = document.createElement("input")
	fileInput.type='file'
	fileInput.style.display='none'
	fileInput.onchange=readFile
	fileInput.func= func
	document.body.appendChild(fileInput)
	clickElem(fileInput)
}

function load_image(img_url, img_ele)
{
    var xhr = new XMLHttpRequest();
    xhr.onload = function()
    {
        var mime = xhr.getResponseHeader("content-type") || "";
        // Blob > ArrayBuffer: http://stackoverflow.com/a/15981017/4200092
        var reader = new FileReader();
        reader.onload = function()
        {
            // TypedArray > Base64 text: http://stackoverflow.com/a/12713326/4200092
            var data = String.fromCharCode.apply(null, new Uint8Array(this.result));
            // img_ele.src = "data:image/png" + ";base64," + btoa(data);
            img_ele.src = "data:" + mime + ";base64," + btoa(data);
        };
        reader.readAsArrayBuffer(this.response);
    };
    xhr.open("get", img_url, true);
    xhr.responseType = "blob";
    xhr.send();
}


</script>
        <style>
body {
    font-family: Calibri;
    font-size: 0.85em;
    background-color: FloralWhite;    
    margin-bottom: 600px;
}

optgroup {
    font-size: 0.85em;
}

select {
    font-size: 0.85em;
}

button {
    font-size: 0.85em;
}


input[type="text"] {
    font-size: 0.85em;
}

table {
    background-color: FloralWhite;    
}

input {
    background-color: FloralWhite;    
}

select {
    background-color: FloralWhite;    
}


#conatiner_msc_table td {
    vertical-align: top;
    white-space: pre;
    font-size: 0.85em;
}


tr[argchecked="True"] {
    background-color: lightgreen;
}

tr[argchecked="False"] {
    background-color: "";
}

#conatiner_msc_table tr:hover {
    background-color: lightblue;
}

button#btn_del_checked {
    color: red;
}

button#btn_moveup_checked {
    color: red;
}

button#btn_movedown_checked {
    color: red;
}

button#btn_demo {
    color: red;
}

button#btn_demo2 {
    color: red;
}

."msc_desc_output_div" {
    padding: 10px 0px 5px 0px;  /* top, right, bottom, left */
}


#container_select_ie_spec_div {
    /* background-color: lightgrey; */
    width: 100%;
    padding: 10px 0px 0px 0px;  /* top, right, bottom, left */
}

#container_select_ie_topchar_div {
    /* background-color: lightgrey; */
    width: 100%;
    padding: 10px 0px 0px 0px;  /* top, right, bottom, left */
}

#container_select_ie_table {
    padding: 10px 0px 0px 0px;  /* top, right, bottom, left */
}

.anchorstyletag {
    padding: 3px 12px 3px 0px;  /* top, right, bottom, left */
    color: blue;
    text-decoration: underline;
    cursor: pointer;
}

#container_select_ie_left_td  {
    border: solid 1px;
    /* width: 50%; */
}

#container_select_ie_right_td  {
    border: solid 1px;
    /* width: 50%; */
    white-space: pre;
    vertical-align: top;
    padding: 0px 10px 0px 10px;
    font-size: small;
}

.ieselect_td_ie {
    white-space: pre;
}

.ieselect_td_ie[clickable]:hover {
    cursor: pointer;
}

.ieselect_td_presence {
    white-space: pre;
}

.ieselect_td_udf {
    white-space: pre;
    max-width: 10ch;
    overflow: hidden;
    text-overflow: ellipsis;
}

.ieselect_td_value {
    
}

.container_select_ie_left_td_inner_table tr:hover {
    background-color: lightblue;
}

.container_select_ie_left_td_inner_table {
    border-collapse: collapse;
}


.container_select_ie_left_td_inner_table td {
    margin: 0px 0px 0px 0px;
    padding: 0px 2px 0px 2px;
    font-size: small;
    border-collapse: collapse;
    border-width: 0px;
    vertical-align: top;
}

/* .container_select_ie_left_td_inner_table button { */
    /* padding: 0px 1px 0px 1px; */
/* } */

*[contenteditable] {
    padding: 2px 5px 2px 5px;
}

li {
    font-size: medium;
    white-space: pre;
}


.treeflag {
    font-family: Courier;
    color: red;
    font-weight: bold;
    vertical-align: middle;
}

.treeflag:hover {
    cursor: pointer;
}


</style>
    </head>
    <body onload="brython(1)">
        <div id="container_msc_app">
            <div id="container_participant">
                <div id="container_participant_buttons">
                    <button id="btn_edit_participant">Edit Participant</button>
                    <button id="btn_save_participant">Save Participant</button>
                </div>
                <div id="container_participant_items"></div>
                <hr>
            </div>

            <div id="container_msc">
                <div id="container_msc_buttons">
                    <button id="btn_add_message" title="add a message at the end">+ Message</button>
                    <button id="btn_add_note", title="add a note at the end">+ Note</button>
                    <button id="btn_add_block" title="add a block at the end">+ Block</button>
                    
                    <button id="btn_del_checked" title="delete the checked rows">DEL</button>
                    <button id="btn_moveup_checked" title="move up the selected rows"></button>
                    <button id="btn_movedown_checked" title="move down the selected rows"></button>
                    
                    <button id="btn_save_msc" title="refresh MSC, indent, message number" style="background-color:lightgreen;">Refresh</button>
                    <button id="btn_import_file" title="open from an previous exported json file">Open File</button>
                    <button id="btn_export_file" title="export to a json file">Export File</button>
                    <button id="btn_open_in_plantuml" title="Open in plantuml.com">Plantuml</button>
                    <button id="btn_demo" title="clean all, then load data/demo.json. If this button is not wrok, please use open file to load demo.json">Demo</button>
                    <button id="btn_demo2" title="clean all, then load data/demo2. If this button is not wrok, please use open file to load demo.json">Demo2</button>
                    <button id="btn_toggle_timer" title="Hide Timer Columns">Hide Timer</button>
                    <button id="btn_refresh_indent" title="refresh indent" style="display:none;">Refresh Indent</button>
                </div>
                
                <div id="container_msc_items">
                    <table  id="conatiner_msc_table">
                        <thead>
                            <tr>
                                <th></th>
                                <th>No</th>
                                <th>Sender</th>
                                <th>Arrow</th>
                                <th>Color</th>
                                <th>Receiver</th>
                                <th>Spec</th>
                                <th>Message</th>
                                <th>IEs List</th>
                                <th>Description</th>
                                <th colSpan=3 class="timer">Timer</th>
                                <th>Command</th>                        
                            </tr>
                        </thead>
                    </table>
                </div>
            </div>
            
            <div id="container_output"></div>
            <a id="container_anchor_plantuml" href="" style="display:none" target="_blank"></a>
        </div>
        
        <div id="container_select_ie_div" style="display:none">
            <div>
                <button id="btn_select_ie_cancel" title="Cancel IE Selection then Return">Cancel</button>
                <button id="btn_select_ie_save" title="Save and Return">Save</button>            
            </div>
            <div id="container_select_ie_spec_div">
                <span>Select Spec</span>
            </div>
            <div id="container_select_ie_topchar_div"></div>
            <table id="container_select_ie_table">
                <tr>
                    <td><button id="btn_select_ie_prev">Prev</button></td>
                    <td id="container_messagetr_message_td" style="background-color: lightgreen;"></td>
                </tr>                
                <tr class="container_select_ie_tr">
                    <td id="container_select_ie_left_td"></td>
                    <td id="container_select_ie_right_td" contenteditable="true"></td>
                </tr>                
            </table>
        </div>
        <script type="text/python">
from browser import document, window, alert, prompt
from browser.html import *






####################################################
####################################################
####################################################







g_data = dict()

def is_rrc(spec):
    return spec in ["36331", "38331"]

def is_nas(spec):
    return spec in ["24301", "24501"]

def is_core(spec):
    return spec in ["36413", "36423", "36443", "36444", "36455", "38413", "38423", "38455", "38463", "38473"]


def load_json(spec):
    if is_nas(spec):
        json = f'../nas/data/{spec}.json'
    else:
        json = f'../asn1/{spec}.json'
    with open(json, encoding='utf-8') as f:
        s = f.read()
        print(json)
    return window.JSON.parse(s)

def get_object(spec):
    try:
        return g_data[spec]
    except:
        #g_data[spec] = load_json(spec)
        g_data[spec] = window.specdata[spec]
        return g_data[spec]

def get_spec_message_list(spec):
    o = get_object(spec)
    result, default = [], None
    if is_rrc(spec):
        # result = [i for i in o.msg_list if i]
        result =  o.topchar_dict["Message"]
        default = "RRCConnectionReconfiguration" if spec == "36331" else "RRCReconfiguration"
    elif is_core(spec):
        # result = [i.name for i in o.section_list if i.is_msg and i.aoa]
        result =  o.topchar_dict["Message"]
    elif is_nas(spec):
        result = [i.name for i in o.msg_list]
    return result, default
    
def get_topchar_list(spec):
    if spec == "":
        return []
    o = get_object(spec)
    if is_rrc(spec):
        # result = ["Message"] + sorted({i[0] for i in o.udf_list})
        result = o.topchar_list
    elif is_core(spec):
        # result = ["Message"] + sorted({i.name[0] for i in o.section_list if i.aoa})
        result = o.topchar_list
    elif is_nas(spec):
        result = ["Message"] + sorted({i.name[0] for i in o.msg_list})
    return result

def get_message_list_by_topchar(spec, topchar):
    if spec == "":
        return []
    o = get_object(spec)
    if topchar == "Message":
        result, default = get_spec_message_list(spec)
        return result
    if is_rrc(spec):
        # result = [i for i in o.udf_list if i[0]==topchar]
        result = o.topchar_dict[topchar]
    elif is_core(spec):
        # result = sorted([i.name for i in o.section_list if i.aoa and i.name[0] == topchar])
        result = o.topchar_dict[topchar]        
    elif is_nas(spec):
        result = sorted([i.name for i in o.msg_list if i.name[0] == topchar])
    return result

def get_message_aoa(spec, name):
    o = get_object(spec)
    if is_rrc(spec):
        # result = o.dct[name]
        result = o.message_dict[name]
        result = format_rrc(result)
    elif is_core(spec):
        # for i in o.section_list:
            # if i.name == name:
                # result = i.aoa
                # break
        result = o.message_dict[name]
        result = format_core(o, result)
    elif is_nas(spec):
        for i in o.msg_list:
            if i.name == name:
                result = i.aoa
                break
        result = format_nas(name, result)
    return result

def format_rrc(aoa):
    result = []
    for row in aoa:
        # flag, treepad, level, ie, udf, value, need, desc, ch5link = row
        flag, treepad, level, need, ie, refer, udf, value, desc, ch5link = row
        d = type("",(),{})
        d.flag = flag
        d.level = level
        d.treepad = treepad
        d.ie = ie
        d.tableview_ie = ">"*d.level + " " + d.ie
        d.need = need
        # d.refer = "Link" if udf else ""
        # d.refer = udf
        d.refer = refer
        d.value = value
        d.desc = desc.replace("<b>", "").replace("</b>", "").replace("<br>", "\n").strip()
        try:
            d.desc = d.desc[:d.desc.index("<a href")]
        except:
            pass
        d.udf = udf
        d.presence = "O" if d.need else "M"
        result.append(d)
    return result
    
def format_core(o, aoa):
    result = []
    for row in aoa:
        # flag, level, ie, need, refer, value, desc, crit, assign = row
        flag, treepad, level, need, ie, refer, udf, value, desc, crit, assign = row
        # treepad, ie = get_pad_and_ie(ie)
        d = type("",(),{})
        d.flag = flag
        d.level = level
        d.treepad = treepad
        d.ie = ie
        d.tableview_ie = ">"*d.level + " " + d.ie
        d.need = need
        d.refer = refer
        d.value = value
        d.desc = desc.replace("<b>", "").replace("</b>", "").replace("<br>", "\n").strip()
        # d.udf = get_name_by_id(o, d.refer)
        d.udf = udf
        p = d.need
        if p == "M" or p == "":
            d.presence = "M"
        elif p == "O" or p == "C":
            d.presence = "O"
        elif p.startswith("0.."):
            d.presence = "O"
            d.value = p
        else:
            d.presence = "M"
            d.value = p
        result.append(d)
    return result

# def get_name_by_id(o, mid):
    # if mid == "":
        # return ""
    # try:
        # return o.id2name[mid]
    # except:
        # o.id2name = {i.id: i.name for i in o.section_list}
        # return o.id2name[mid]

# def get_pad_and_ie(text):
    # for i, c in enumerate(text):
        # if c.lower() in 'abcdefghijklmnopqrstuvwxyz':
            # break
    # pad, ie = text[:i], text[i:]
    # a = r" "  # last
    # b = r" "  # middle    
    # c = r"  "  # up
    # d = r"   "  # down    
    
    # a1 = r""  # last
    # b1 = r""  # middle    
    # c1 = r" "  # up
    # d1 = r"  "  # down    
    # pad = pad.replace(a, a1).replace(b, b1).replace(c, c1).replace(d, d1)
    # return pad, ie


def format_nas(name, aoa):
    col_ie = 1
    col_presence = 3
    result = []
    d = type("",(),{})
    d.ie = name
    d.presence = "M"
    result.append(d)
    for row in aoa[1:]:
        d = type("",(),{})
        d.ie = "> " + row[col_ie]
        d.presence = row[col_presence]
        result.append(d)
    return result








####################################################
####################################################
####################################################







g_pre_defined_participant_list = ["", 
"UE", 
"eNB", "Source eNB", "Target eNB", 
"MME", "SGW", "PGW", "SGW/PGW", "EPC", 
"en-gNB", "ng-eNB", 
"gNB", "Source gNB", "Target gNB", 
"AMF", "SMF", "UPF", "SMF/UPF", "5GC"]

#############################################################################################
#                            Common Util                                                    #
#############################################################################################
def get_select_value(select):
    return select.options[select.selectedIndex].value

def set_select_value(select, value):
    r = [o.value for o in select.options]
    if value in r:
        select.selectedIndex = r.index(value)

def create_select(value_list):
    s = SELECT([OPTION(i) for i in value_list])
    s.style.width = "100%"
    return s

class ParticipantTable:
    def __init__(self, participant_list=[]):
        self.table = TABLE()
        self.table <= THEAD(TR(TH("Select One")+TH("Input One")+TH("Command")))
        self.trs_dict = {}
        for value in participant_list:
            self.table <= ParticipantTR(self, value).tr
        self.table <= ParticipantTR(self).tr
            
    def get_participant_list(self):
        trs = self.table.select("tr.participantrow")
        rows = [self.trs_dict[tr.id] for tr in trs]
        return [r.get_value() for r in rows if r.get_value()]
            
#############################################################################################
#                            BaseTR                                                         #
#############################################################################################
class ParticipantTR:
    def __init__(self, parent_table, value=""):
        self.tr = TR(Class="participantrow")
        self.participant_select = create_select(g_pre_defined_participant_list)
        self.select_td = TD(self.participant_select)
        self.tr <= self.select_td
        #
        self.participant_input_text = INPUT(type='text', value='')
        self.input_text_td = TD(self.participant_input_text)
        self.tr <= self.input_text_td
        #
        self.append_command_td()
        self.bind()
        #
        self.parent_table = parent_table
        self.id = str(id(self))
        self.tr.id = self.id
        self.parent_table.trs_dict[self.id] = self
        self.set_value(value)

    def get_value(self):
        return get_select_value(self.participant_select) + self.participant_input_text.value

    def set_value(self, value):
        if value in g_pre_defined_participant_list:
            set_select_value(self.participant_select, value)
        else:
            self.participant_input_text.value = value
        
    def append_command_td(self):
        self.btn_add = BUTTON("+", title="insert at next row")
        self.btn_del = BUTTON("-", title="delete")
        self.btn_up = BUTTON("", title="move up")
        self.btn_down = BUTTON("", title="move down")
        self.btn_span = SPAN()
        self.btn_span <= self.btn_add
        self.btn_span <= self.btn_del
        self.btn_span <= self.btn_up
        self.btn_span <= self.btn_down        
        self.command_td = TD()        
        self.command_td <= self.btn_span
        self.tr <= self.command_td
        #self.btn_del.style.display = "none"
        #self.btn_up.style.display = "none"
        #self.btn_down.style.display = "none"

    def bind(self):
        for callback_func_name in dir(self):
            if callback_func_name.startswith("callback_"):
                event_name = callback_func_name.split("_")[1]
                element_name = "_".join(callback_func_name.split("_")[2:])
                callback_func = getattr(self, callback_func_name)
                element = getattr(self, element_name)
                element.bind(event_name, callback_func)
    
    def callback_click_btn_add(self, event=None):
        t = ParticipantTR(self.parent_table)
        self.tr.insertAdjacentElement("afterend", t.tr)
        
    def callback_click_btn_del(self, event=None):
        del self.parent_table.trs_dict[self.id]    
        self.tr.remove()

    def callback_click_btn_up(self, event=None):
        p = self.tr.previousSibling
        if isinstance(p, TR): # if hasattr(p, "insertAdjacentElement"):
            p.insertAdjacentElement("beforebegin", self.tr)
            self.btn_up.focus()
        
    def callback_click_btn_down(self, event=None):
        p = self.tr.nextSibling
        if isinstance(p, TR): # if p is not None:
            p.insertAdjacentElement("afterend", self.tr)
            self.btn_down.focus()

    def callback_change_participant_select(self, event=None):
        self.participant_input_text.value = ""
        
    def callback_change_participant_input_text(self, event=None):
        set_select_value(self.participant_select, "")







####################################################
####################################################
####################################################







class Description:
    def __init__(self):
        self.div = DIV()
        self.div_btn = DIV()
        self.div <= self.div_btn
        self.btn_show = BUTTON("Show Description")
        self.btn_hide = BUTTON("Hide Description")
        self.div_btn <= self.btn_show
        self.div_btn <= self.btn_hide
        self.div_textarea = DIV()
        self.div <= self.div_textarea
        self.textarea = TEXTAREA()
        self.div_textarea <= self.textarea
        self.bind()
        self.callback_click_btn_hide()

    def bind(self):
        for callback_func_name in dir(self):
            if callback_func_name.startswith("callback_"):
                event_name = callback_func_name.split("_")[1]
                element_name = "_".join(callback_func_name.split("_")[2:])
                callback_func = getattr(self, callback_func_name)
                element = getattr(self, element_name)
                element.bind(event_name, callback_func)
                #print(f"self.{element_name}.bind('{event_name}', self.{callback_func_name})")

    def callback_click_btn_show(self, event=None):
        self.btn_show.style.display = "none"
        self.btn_hide.style.display = ""
        self.textarea.style.display = ""

    def callback_click_btn_hide(self, event=None):
        self.btn_show.style.display = ""
        self.btn_hide.style.display = "none"
        self.textarea.style.display = "none"
        self.btn_show.title = self.get_text()

    def get_text(self):
        return self.textarea.value
        
    def set_text(self, text):
        self.textarea.value = text
        self.btn_show.title = self.get_text()
        







####################################################
####################################################
####################################################







g_arrow_list = ["->", "-->", "<->", "<-->", "-x", "--x"]
g_arrow_color_list = ["black", "red", "orange", "green", "blue", "purple", "brown"]
g_spec_list = ["", 
               "36331", 
               "36413", 
               "36423", 
               "36443", 
               "36444", 
               "36455", 
               "38331", 
               "38413", 
               "38423", 
               "38455",
               "38463", 
               "38473", 
               "24301", 
               "24501"]
g_protocol_dict = {"":"", 
                   "36331":"LTE RRC", 
                   "36413":"S1AP", 
                   "36423":"X2AP", 
                   "36443":"M2AP", 
                   "36444":"M3AP", 
                   "36455":"LPPa", 
                   "38331":"NR RRC", 
                   "38413":"NGAP", 
                   "38423":"XnAP", 
                   "38455":"NRPPa", 
                   "38463":"E1AP", 
                   "38473":"F1AP", 
                   "24301":"LTE NAS", 
                   "24501":"NR NAS"}


#############################################################################################
#                            Common Util                                                    #
#############################################################################################
def get_select_value(select):
    return select.options[select.selectedIndex].value

def set_select_value(select, value):
    r = [o.value for o in select.options]
    if value in r:
        select.selectedIndex = r.index(value)

def get_select_range(select):
    return [o.value for o in select.options]

def update_select_range(select, new_range):
    value = get_select_value(select)
    select.clear()
    for i in new_range:
        select <= OPTION(i)
    if value in new_range:
        select.selectedIndex = new_range.index(value)

def create_select(value_list, title_list=None, full_width=True, **kwargs):
    if title_list is None:
        #s = SELECT(OPTGROUP([OPTION(i) for i in value_list]))
        s = SELECT([OPTION(i) for i in value_list])
    else:
        #s = SELECT(OPTGROUP([OPTION(i, title=t) for i, t in zip(value_list, title_list)]))
        s = SELECT([OPTION(i, title=t) for i, t in zip(value_list, title_list)])
    if full_width:
        s.style.width = "100%"
    for k, v in kwargs.items():
        setattr(s, k, v)
    #s.style.fontSize = "0.75em"
    return s

def set_editable(ele):
    ele.style.borderStyle = "solid"
    ele.style.borderWidth = "1px"
    ele.contentEditable = "True"

def set_not_editable(ele):
    ele.style.borderStyle = "none"
    # ele.style.borderWidth = "0px"
    ele.contentEditable = "False"

def set_indent(td, level):
    indent = int(level)
    if indent < 0:
        indent = 0
    # if indent:
        # indent = f'{indent*2}em'
        # td.style.paddingLeft = indent
    indent = f'{indent*2}em'
    td.style.paddingLeft = indent

#############################################################################################
#                            BaseTR                                                         #
#############################################################################################
class BaseTR:
    def __init__(self, app, **kwagrs):
        self.app = app
        self.participant_list = self.app.participant_list
        self.tr = TR(Class="mscrow")
        self.tr.argchecked = "False"
        #
        self.first_input_checkbox = INPUT(type="checkbox")
        self.checkbox_td = TD()
        self.checkbox_td <= self.first_input_checkbox
        self.tr <= self.checkbox_td
        #
        self.message_no_td = TD()
        self.tr <= self.message_no_td
        #
        self.init()
        self.append_command_td()
        self.bind()
        self.add_to_message_dict()
        
    def init(self):
        pass

    @property
    def line(self):
        pass
        
    def is_checked(self):
        return self.tr.argchecked == "True"

    def add_to_message_dict(self):
        self.id = str(id(self))
        self.tr.id = self.id
        self.app.trs_dict[self.id] = self
    
    def __getattr__(self, name):
        n = f"{name}_select"
        if n in self.__dict__:
            select = self.__dict__[n]
            if select.style.display != "none":
                s = select.options[select.selectedIndex].value
                return s
        n = f"{name}_input_text"
        if n in self.__dict__:
            input_text = self.__dict__[n]
            if input_text.style.display != "none":
                return input_text.value
        print("no attribute:", name)
        raise
        
    def append_command_td(self):
        self.btn_add = BUTTON("+", title="insert at next row")
        self.btn_del = BUTTON("-", title="delete")
        self.btn_up = BUTTON("", title="move up")
        self.btn_down = BUTTON("", title="move down")
        self.btn_span = SPAN()
        self.btn_span <= self.btn_add
        self.btn_span <= self.btn_del
        self.btn_span <= self.btn_up
        self.btn_span <= self.btn_down        
        self.command_td = TD()        
        self.command_td <= self.btn_span
        self.tr <= self.command_td
        # self.btn_del.style.display = "none"
        # self.btn_up.style.display = "none"
        # self.btn_down.style.display = "none"

    def bind(self):
        for callback_func_name in dir(self):
            if callback_func_name.startswith("callback_"):
                event_name = callback_func_name.split("_")[1]
                element_name = "_".join(callback_func_name.split("_")[2:])
                callback_func = getattr(self, callback_func_name)
                element = getattr(self, element_name)
                element.bind(event_name, callback_func)
    
    def callback_click_btn_add(self, event=None):
        t = TempTR(self.app)
        self.tr.insertAdjacentElement("afterend", t.tr)
        self.app.refresh_message_no()
        
    def callback_click_btn_del(self, event=None):
        del self.app.trs_dict[self.id]
        self.tr.remove()
        self.app.refresh_common()

    def callback_click_btn_up(self, event=None):
        p = self.tr.previousSibling
        if isinstance(p, TR): # if hasattr(p, "insertAdjacentElement"):
            p.insertAdjacentElement("beforebegin", self.tr)
            #self.btn_up.focus()
        self.app.refresh_common()
        
    def callback_click_btn_down(self, event=None):
        p = self.tr.nextSibling
        if isinstance(p, TR): # if p is not None:
            p.insertAdjacentElement("afterend", self.tr)
            #self.btn_down.focus()
        self.app.refresh_common()

    def callback_change_first_input_checkbox(self, event=None):
        self.tr.argchecked = str(self.first_input_checkbox.checked)

    def update_participant(self):
        pass

    def export_obj(self):
        o = dict()
        o["classname"] = self.__name__
        return o

    def import_obj(self, data):
        pass

    def set_indent(self, indent):
        pass
        
#############################################################################################
#                            MessageTR                                                      #
#############################################################################################
class MessageTR(BaseTR):
    def init(self):
        self.activate_message_no_td()
        self.sender_select = create_select(self.participant_list)
        self.sender_td = TD(self.sender_select)
        self.arrow_select = create_select(g_arrow_list)
        self.arrow_td = TD(self.arrow_select)
        self.arrow_color_select = create_select(g_arrow_color_list)
        self.arrow_color_td = TD(self.arrow_color_select)
        for op in self.arrow_color_select.select("option"):
            op.style.backgroundColor = op.text
        self.receiver_select = create_select(self.participant_list)
        self.receiver_td = TD(self.receiver_select)
        self.spec_select = create_select(g_spec_list)
        self.spec_td = TD(self.spec_select)
        self.message_td = TD(title="Message field")
        self.message_select = None
        # self.message_td <= self.message_select
        set_editable(self.message_td)        
        self.ie_td = TD(title="IEs List field")
        set_editable(self.ie_td)
        
        self.description = Description()
        self.desc_td = TD(self.description.div)
        
        self.timer_td = TD(Class="timer")
        self.timer2_td = TD(Class="timer")
        self.timer3_td = TD(Class="timer")
        self.timer_owner_select = create_select(["", self.sender, self.receiver])
        self.timer_action_select = create_select(["", "start", "stop", "expire"])
        self.timer_name_input_text = INPUT(type='text', title="timer name")
        self.timer_td <= self.timer_owner_select
        self.timer2_td <= self.timer_action_select
        self.timer3_td <= self.timer_name_input_text
        self.timer_name_input_text.style.width = "10ch"
        #
        self.tr <= self.sender_td
        self.tr <= self.arrow_td
        self.tr <= self.arrow_color_td
        self.tr <= self.receiver_td
        self.tr <= self.spec_td
        self.tr <= self.message_td
        self.tr <= self.ie_td
        self.tr <= self.desc_td
        self.tr <= self.timer_td
        self.tr <= self.timer2_td
        self.tr <= self.timer3_td
        #
        self.callback_change_spec_select(None)
        self.callback_change_arrow_color_select(None)

    def callback_change_sender_select(self, event=None):
        new_range = ["", self.sender, self.receiver]
        update_select_range(self.timer_owner_select, new_range)

    def callback_change_receiver_select(self, event=None):
        self.callback_change_sender_select()

    @property
    def line(self):
        s = f'"{self.sender}" {self._arrow} "{self.receiver}"'
        lines = [self.message.strip()] + self.ie.strip().split("\n")
        lines = [_i.strip() for _i in lines if _i.strip()]
        if self.arrow_color == "black":
            lines = [f"{_i}" for _i in lines]
        else:
            lines = [f"<color {self.arrow_color}>{_i}</color>" for _i in lines]
        m = "\\n".join(lines)
        # m = self.message.strip() + "\n" + self.ie.strip()
        # m = m.strip().replace("\n", "\\n")
        if m:
            # m = f"<color {self.arrow_color}>{m}</color>"
            if self.protocol:
                p = f"<color {self.arrow_color}>{self.protocol}</color>"
                s = s + " : " + p + ": " + m
            else:
                s = s + " : " + m
        t = self.get_timer_lines()
        s = s + "\n" + t
        
        s = "\n".join([self.autonumber_pre_line, s, self.autonumber_post_line])
        s = s.strip()
        return s.strip()

    def get_timer_lines(self):
        if self.timer_owner and self.timer_action and self.timer_name:
            sender_index = self.app.participant_list.index(self.sender)
            receiver_index = self.app.participant_list.index(self.receiver)
            if sender_index <= receiver_index:
                # sender at left
                pos = "left" if self.timer_owner == self.sender else "right"
            else:
                pos = "right" if self.timer_owner == self.sender else "left"
            noteline = f"rnote {pos} #white: <color black><size:10>{self.timer_action} {self.timer_name}</size></color>"
            a = {"start":"activate", "stop":"deactivate", "expire":"destroy"}[self.timer_action]
            #b = getattr(self, self.timer_owner)
            b = self.timer_owner
            lifeline = f'{a} "{b}"'
            return "\n".join([noteline, lifeline])
        return ""

    @property
    def protocol(self):
        return g_protocol_dict[self.spec]

    @property
    def _arrow(self):
        return self.arrow[0] + f"[#{self.arrow_color}]" + self.arrow[1:]

    @property
    def message(self):
        if self.message_select is not None:
            return get_select_value(self.message_select)
        else:
            return self.message_td.text.strip()

    @property
    def ie(self):
        return self.ie_td.text.strip()

    def callback_change_spec_select(self, event=None):
        spec = self.spec
        if spec != "":
            self.message_td.clear()
            set_not_editable(self.message_td)
            pmsg_list, default = get_spec_message_list(spec)
            self.message_select = create_select(pmsg_list)
            self.message_td <= self.message_select
            if default is not None:
                self.message_select.selectedIndex = pmsg_list.index(default)
        else:
            self.message_select = None
            self.message_td.clear()
            set_editable(self.message_td)

    def callback_change_arrow_color_select(self, event=None):
        self.arrow_color_select.style.backgroundColor = self.arrow_color if self.arrow_color != 'black' else ""
        self.arrow_select.style.color = self.arrow_color

    def set_message_no(self, i):
        self.message_no_td.text = str(i)

    def update_participant(self):
        update_select_range(self.sender_select, self.app.participant_list)
        self.callback_change_sender_select()
        update_select_range(self.receiver_select, self.app.participant_list)
        self.callback_change_receiver_select()

    def export_obj(self):
        o = dict()
        o["classname"] = self.__name__
        data = dict()
        data["sender"] = self.sender
        data["arrow"] = self.arrow
        data["arrow_color"] = self.arrow_color
        data["receiver"] = self.receiver
        data["spec"] = self.spec
        data["message"] = self.message
        data["ie"] = self.ie
        data["description"] = self.description.get_text()
        data["timer_owner"] = self.timer_owner
        data["timer_action"] = self.timer_action
        data["timer_name"] = self.timer_name
        if not self.is_auto_message_no():
            data["manual_message_no"] = self._message_no
        o["data"] = data
        return o

    def import_obj(self, data):
        set_select_value(self.sender_select, data["sender"])
        self.callback_change_sender_select()
        
        set_select_value(self.arrow_select, data["arrow"])
        set_select_value(self.arrow_color_select, data["arrow_color"])
        self.callback_change_arrow_color_select()
        
        set_select_value(self.receiver_select, data["receiver"])
        self.callback_change_receiver_select()
        
        set_select_value(self.spec_select, data["spec"])
        self.callback_change_spec_select()
        #
        if data["spec"]:
            set_select_value(self.message_select, data["message"])
        else:
            self.message_td.text = data["message"]
        #
        self.ie_td.text = data["ie"]
        if "description" in data:
            self.description.set_text(data["description"])
        set_select_value(self.timer_owner_select, data["timer_owner"])
        set_select_value(self.timer_action_select, data["timer_action"])
        self.timer_name_input_text.value = data["timer_name"]
        if "manual_message_no" in data:
            self.set_to_manual_message_no_td(data["manual_message_no"])

    def set_indent(self, indent):
        set_indent(self.sender_td, indent)

    def append_command_td(self):
        super().append_command_td()
        self.btn_ieselect = BUTTON("IE", title="select IEs for IEs List field")
        self.btn_span <= self.btn_ieselect

    def callback_click_btn_ieselect(self, event=None):
        self.app.ieselect.activate(self)

    def activate_message_no_td(self):
        td = self.message_no_td
        td.contentEditable = "True"
        td.title = "editable, \nit is highlighted with a differernt background if use a manually set value"
        td.auto = "1"
        td.valueonfocus = ""
        td.bind("focus", self.focus_on_message_no_td)
        td.bind("blur", self.blur_on_message_no_td)
        
    def focus_on_message_no_td(self, event=None):
        td = self.message_no_td
        td.valueonfocus = self._message_no
    
    def blur_on_message_no_td(self, event=None):
        td = self.message_no_td
        if td.valueonfocus != self._message_no:
            self.set_to_manual_message_no_td()
        td.valueonfocus = ""
        self.app.refresh_message_no()

    def set_to_auto_message_no_td(self):
        td = self.message_no_td
        td.auto = "1"
        td.style.backgroundColor = ""

    def set_to_manual_message_no_td(self, value=None):
        td = self.message_no_td
        td.auto = "0"
        td.style.backgroundColor = "khaki"
        if value is not None:
            td.text = value
    
    def is_auto_message_no(self):
        return self.message_no_td.auto == "1"

    @property
    def autonumber_pre_line(self):
        # autonumber start_no "0 "
        # autonumber stop
        # autonumber resume "0 "
        if self.is_auto_message_no():
            s = ""
        else:
            if self.is_blank_message_no():
                s = "autonumber stop" 
            else:
                num, fmt = self.get_manual_message_no_and_format()
                s = f'autonumber {num} "<b>0{fmt} "'
        return s

    @property
    def _message_no(self):
        return self.message_no_td.text.strip()

    def is_blank_message_no(self):
        return self._message_no == ""

    def get_manual_message_no_and_format(self):
        s = self._message_no
        result = []
        for i, c in enumerate(s):
            if c in '0123456789':
                result.append(c)
            else:
                break
        r = ''.join(result)
        format = "" if len(r) == len(s) else s[i:]
        num = int(r)
        return num, format

    @property
    def autonumber_post_line(self):
        if self.autonumber_pre_line:
            s = 'autonumber resume "<b>0 "'
        else:
            s = ""
        return s

#############################################################################################
#                            NoteTR                                                         #
#############################################################################################
class NoteTR(BaseTR):
    def init(self):
        self.note_select = create_select(["rnote", "hnote"], title_list=["rectangle", "hexagon"])
        self.note_td = TD(self.note_select)

        self.position_select = create_select(["over"])
        self.position_td = TD(self.position_select)

        self.participant1_select = create_select(self.participant_list)
        self.participant1_td = TD(self.participant1_select)

        self.participant2_select = create_select(self.participant_list)
        self.participant2_td = TD(self.participant2_select)

        self.text_td = TD(colSpan=3, title="Note Content Field")
        set_editable(self.text_td)        
        
        self.tr <= self.note_td
        self.tr <= self.position_td
        self.tr <= self.participant1_td
        self.tr <= self.participant2_td
        self.tr <= TD(colSpan=1)
        self.tr <= self.text_td
        self.tr <= TD(colSpan=3, Class="timer")

    def callback_change_participant1_select(self, event):
        set_select_value(self.participant2_select, self.participant1)

    @property
    def text(self): 
        return self.text_td.text

    @property
    def line(self):
        s = f'{self.note} {self.position} "{self.participant1}", "{self.participant2}": '
        c = self.text.strip().replace("\n", "\\n")
        return s + c if c else ""

    def update_participant(self):
        update_select_range(self.participant1_select, self.app.participant_list)
        update_select_range(self.participant2_select, self.app.participant_list)

    def export_obj(self):
        o = dict()
        o["classname"] = self.__name__
        data = dict()
        data["note"] = self.note
        data["position"] = self.position
        data["participant1"] = self.participant1
        data["participant2"] = self.participant2
        data["text"] = self.text        
        o["data"] = data
        return o

    def import_obj(self, data):
        set_select_value(self.note_select, data["note"])
        set_select_value(self.position_select, data["position"])
        set_select_value(self.participant1_select, data["participant1"])
        set_select_value(self.participant2_select, data["participant2"])
        self.text_td.text = data["text"]

    def set_indent(self, indent):
        set_indent(self.note_td, indent)


#############################################################################################
#                            BlockTR                                                        #
#############################################################################################
class BlockTR(BaseTR):
    def init(self):
        self.block_select = create_select(["", "alt", "par", "opt", "group", "else", "end", "title"])
        self.block_td = TD(self.block_select)
        self.tr <= self.block_td
        self.text_td = TD(colSpan=3)
        set_editable(self.text_td)
        self.tr <= TD(colSpan=4)
        self.tr <= self.text_td
        self.tr <= TD(colSpan=3, Class="timer")

    @property
    def text(self): 
        return self.text_td.text

    @property
    def line(self):
        if self.block == "end":
            return self.block 
        else:
            return self.block + " " + self.text.strip().replace("\n", "\\n")

    def callback_change_block_select(self, event=None):
        if self.block == "end":
            set_not_editable(self.text_td)
        else:
            set_editable(self.text_td)
        self.app.refresh_common()

    def export_obj(self):
        o = dict()
        o["classname"] = self.__name__
        data = dict()
        data["block"] = self.block
        data["text"] = self.text
        o["data"] = data
        return o

    def import_obj(self, data):
        set_select_value(self.block_select, data["block"])
        self.text_td.text = data["text"]
        self.callback_change_block_select()

    def set_indent(self, indent):
        set_indent(self.block_td, indent)

#############################################################################################
#                            TempTR                                                         #
#############################################################################################       
class TempTR(BaseTR):
    def init(self):
        self.btn_add_m = BUTTON("Insert Message")
        self.btn_add_n = BUTTON("Inser Note")
        self.btn_add_b = BUTTON("Insert Block")
        self.command_td = TD(colSpan=8)        
        self.command_td <= self.btn_add_m
        self.command_td <= self.btn_add_n
        self.command_td <= self.btn_add_b
        self.tr <= self.command_td
        self.tr <= TD(colSpan=3, Class="timer")

    def callback_click_btn_add_m(self, event):
        t = MessageTR(self.app)
        self.tr.insertAdjacentElement("afterend", t.tr)
        self.callback_click_btn_del(None)

    def callback_click_btn_add_n(self, event):
        t = NoteTR(self.app)
        self.tr.insertAdjacentElement("afterend", t.tr)
        self.callback_click_btn_del(None)

    def callback_click_btn_add_b(self, event):
        t = BlockTR(self.app)
        self.tr.insertAdjacentElement("afterend", t.tr)
        self.callback_click_btn_del(None)







####################################################
####################################################
####################################################







#############################################################################
# tree
#############################################################################
col_flag = 1
col_level = 2
col_ie = 3
# col_udf = 5

minus = '-'
plus = '+'

def get_level(tr):
    try:
        return int(tr.cells[col_level].html)
    except:
        return None

def get_flag_td(tr):
    return tr.cells[col_flag]
        
def get_flag(tr):
    return get_flag_td(tr).html

def set_flag(tr, flag):
    if get_flag(tr) != flag:
        get_flag_td(tr).html = flag

def get_treepad(tr):
    try:
        return tr.cells[col_ie].select("span")[0].text
    except:
        return ''

def get_udf(tr):
    try:
        return tr.udf
    except:
        return ''
    
#############################################################################
# flag
#############################################################################
        
def show(ele):
    ele.style.display = ''
    
def hide(ele):
    ele.style.display = 'none'

#############################################################################
# flag action
#############################################################################
def collapse(tr):
    set_flag(tr, plus)
    level = get_level(tr)
    tr = tr.nextElementSibling
    while tr and get_level(tr) > level:
        hide(tr)
        tr = tr.nextElementSibling
    
def expand(tr):
    set_flag(tr, minus)
    level = get_level(tr)
    tr = tr.nextElementSibling
    while tr:
        nlevel = get_level(tr)
        if nlevel-1 == level:
            show(tr)
            if get_flag(tr) == minus:
                expand(tr)
        elif nlevel <= level:
            break
        tr = tr.nextElementSibling
        
def click_flag(event):
    t = event.target
    while True:
        if t.tagName in ('TABLE', 'A'):
            return
        if t.tagName == 'TR':
            tr = t
            break
        else:
            t = t.parent
    flag = get_flag(tr)
    if flag == minus:
        collapse(tr)
    else: # flag == plus
        ntr = tr.nextElementSibling
        if get_level(ntr) == get_level(tr) + 1:
            expand(tr)
        else:
            window.g_app.ieselect.append_child(tr)
    
    # elif flag == plus:
        # try:
            # ntr = tr.nextElementSibling
            # if get_level(ntr) == get_level(tr) + 1:
                # expand(tr)
            # else:
                # print("here")
                # window.g_app.ieselect.append_child(tr)
        # except:
            # print('error 88')
            # expand(tr)
            # raise








####################################################
####################################################
####################################################






# import ready

#############################################################################################
#                            Common Util                                                    #
#############################################################################################
def get_select_value(select):
    return select.options[select.selectedIndex].value

def set_select_value(select, value):
    r = [o.value for o in select.options]
    if value in r:
        select.selectedIndex = r.index(value)

def get_select_range(select):
    return [o.value for o in select.options]

def update_select_range(select, new_range):
    value = get_select_value(select)
    select.clear()
    for i in new_range:
        select <= OPTION(i)
    if value in new_range:
        select.selectedIndex = new_range.index(value)

def create_select(value_list, title_list=None, full_width=True, **kwargs):
    if title_list is None:
        #s = SELECT(OPTGROUP([OPTION(i) for i in value_list]))
        s = SELECT([OPTION(i) for i in value_list])
    else:
        #s = SELECT(OPTGROUP([OPTION(i, title=t) for i, t in zip(value_list, title_list)]))
        s = SELECT([OPTION(i, title=t) for i, t in zip(value_list, title_list)])
    if full_width:
        s.style.width = "100%"
    for k, v in kwargs.items():
        setattr(s, k, v)
    #s.style.fontSize = "0.75em"
    return s

#############################################################################################
#                            IESelect                                                       #
#############################################################################################

class IESelect:
    def __init__(self, spec_list):
        for tag in document.select("[id]"):
            setattr(self, tag.id, tag)
        self.spec_select = create_select(spec_list, full_width=False)
        self.container_select_ie_spec_div <= self.spec_select
        self.bind()
        # self.spec_select.bind("change", self.callback_change_spec_select)
        self.cleanup()

    def __getattr__(self, name):
        n = f"{name}_select"
        if n in self.__dict__:
            select = self.__dict__[n]
            if select.style.display != "none":
                s = select.options[select.selectedIndex].value
                return s
        n = f"{name}_input_text"
        if n in self.__dict__:
            input_text = self.__dict__[n]
            if input_text.style.display != "none":
                return input_text.value
        print("no attribute:", name)
        raise
        
    def bind(self):
        for callback_func_name in dir(self):
            if callback_func_name.startswith("callback_"):
                event_name = callback_func_name.split("_")[1]
                element_name = "_".join(callback_func_name.split("_")[2:])
                callback_func = getattr(self, callback_func_name)
                element = getattr(self, element_name)
                element.bind(event_name, callback_func)

    def cleanup(self):
        self.container_select_ie_topchar_div.clear()
        self.container_select_ie_left_td.clear()
        self.container_select_ie_right_td.clear()
        self.container_messagetr_message_td.clear()
        self.message = ""
        self.topchar = ""
        self.mtr = None
        self.history = []

    def activate(self, mtr):
        self.cleanup()
        self.mtr = mtr
        self.message = mtr.message
        self.topchar = ""
        set_select_value(self.spec_select, mtr.spec)
        self.callback_change_spec_select()
        self.update_left_div_by_message()
        self.container_select_ie_div.style.display = ""
        self.container_msc_app.style.display = "none"
        self.container_messagetr_message_td.text = ": ".join([mtr.protocol, mtr.message])
        self.container_select_ie_right_td.text = mtr.ie
        self.history.append(self.message)

    def callback_click_btn_select_ie_cancel(self, event=None):
        self.cleanup()
        self.container_select_ie_div.style.display = "none"
        self.container_msc_app.style.display = ""

    def callback_click_btn_select_ie_save(self, event=None):
        text = self.container_select_ie_right_td.text
        mtr = self.mtr
        mtr.ie_td.text = text
        self.cleanup()
        self.container_select_ie_div.style.display = "none"
        self.container_msc_app.style.display = ""
        mtr.ie_td.focus()

    def callback_click_btn_select_ie_prev(self, event=None):
        if len(self.history) >= 2:
            self.history.pop()
            self.message = self.history[-1]
            self.update_left_div_by_message()
        else:
            self.history = []
        self.btn_select_ie_prev.title = "\n".join(self.history[::-1])

    def callback_change_spec_select(self, event=None):
        topchar_list = get_topchar_list(self.spec)
        self.update_topchar_div(topchar_list)
        self.topchar = "Message"
        self.update_left_div_by_topchar()

    # def change_ie_checkbox(self, event=None):
        # pass
        # # set r3c2

    def update_topchar_div(self, topchar_list):
        ele = self.container_select_ie_topchar_div
        ele.clear()
        for c in topchar_list:
            tag = SPAN(c, Class="anchorstyletag")
            ele <= tag
            tag.bind("click", self.click_topchar)

    def click_topchar(self, event):
        self.topchar = event.target.text
        self.update_left_div_by_topchar()
        
    def update_left_div_by_topchar(self):
        message_list = get_message_list_by_topchar(self.spec, self.topchar)
        ele = self.container_select_ie_left_td
        ele.clear()
        for c in message_list:
            tag = DIV(c, Class="anchorstyletag")
            ele <= tag
            tag.bind("click", self.click_message)

    def click_message(self, event):
        self.message = event.target.text
        self.update_left_div_by_message()
        self.append_history(self.message)

    def click_ie(self, event):
        self.message = event.target.title
        self.update_left_div_by_message()
        self.append_history(self.message)
            
    def append_history(self, message):
        self.history.append(self.message)
        self.btn_select_ie_prev.title = "\n".join(self.history[::-1])
            
    def update_left_div_by_message(self):
        ele = self.container_select_ie_left_td
        ele.clear()
        if is_rrc(self.spec) or is_core(self.spec):
            ele <= self.create_rrc_core_message_table()
        elif is_nas(self.spec):
            ele <= self.create_nas_message_table()
        else:
            return

    def create_rrc_core_message_table(self):
        aoa = get_message_aoa(self.spec, self.message)
        table = TABLE(Class="container_select_ie_left_td_inner_table")
        table <= TR([TH(s) for s in ["", "", "", "IE", "Presence", "Type", "Value"]])
        for d in aoa:
            tr = self.create_tree_tr(d)
            table <= tr
        return table

    def create_nas_message_table(self):
        aoa = get_message_aoa(self.spec, self.message)
        table = TABLE(Class="container_select_ie_left_td_inner_table")
        table <= TR([TD(s) for s in ["", "IE", "Presence"]])
        for d in aoa:
            tr = TR()
            table <= tr
            tr.spec = self.spec
            tr.spectype = "nas"
            # cb = INPUT(type="checkbox")
            # cb.bind("change", self.change_ie_checkbox)
            # tr <= TD(cb)
            cb = BUTTON("=>", title="append IE")
            cb.bind("click", self.click_append_ie)
            tr <= TD(cb)
            cb.style.fontSize = "xx-small"
            cb.style.margin = "0px 0px 0px 0px"
            cb.style.margin = "0px 0px 0px 0px"
            
            tr <= TD(d.ie, Class=f"ieselect_td_ie")
            if d.presence == "M":
                tr <= TD(d.presence, Class=f"ieselect_td_presence")
            if d.presence == "O":
                tr <= TD(create_select(["N", "Y"]), Class=f"ieselect_td_presence")
        return table

    def click_append_ie(self, event=None):
        col_presence = 4
        col_value = 6
        tr = event.target.parent.parent
        if is_rrc(tr.spec) or is_core(tr.spec):
            ie = tr.tableview_ie
            presence_td = tr.cells[col_presence]
            value_td = tr.cells[col_value]
            if is_rrc(tr.spec):
                if ie.replace(">", "").strip() in ("lateNonCriticalExtension", "nonCriticalExtension") and hasattr(tr, "udf"):
                    ie = ">"*int(tr.cells[2].text) + " " + tr.udf
        if is_nas(tr.spec):
            ie = tr.cells[1].text
            presence_td = tr.cells[2]
        if presence_td.html == "M":
            presence = "M"
        else:
            presence_select = presence_td.select("select")[0]
            presence = get_select_value(presence_select)
        #
        try:
            value_td = tr.cells[col_value]
            value_select = value_td.select("select")[0]
            value = get_select_value(value_select)
        except:
            value = ""
        
        if value =="":
            if presence == "M":
                s = f"{ie}"
            if presence == "Y":
                # s = f"{ie}: present"
                s = f"{ie}"
            if presence == "N":
                s = f"{ie}: absent"
        else:
            if presence == "M":
                s = f'{ie}="{value}"'
            if presence == "Y":
                s = f'{ie}="{value}"'
            if presence == "N":
                s = f"{ie}: absent"
        ele = self.container_select_ie_right_td
        ele.text = "\n".join([ele.text, s]).strip()

    def append_child(self, tr):
        # aoa = get_message_aoa(spec, ready.get_udf(tr))
        aoa = self.get_remain(get_udf(tr))
        if aoa:
            start_level = get_level(tr)
            pad_prefix = get_treepad(tr)
            pad_prefix = pad_prefix.replace(r"", r" ").replace(r"", r"").replace(r"", r" ")
            cur = tr
            for d in aoa:
                new = self.create_tree_tr(d, pad_prefix, start_level)
                cur.insertAdjacentElement("afterend", new)
                cur = new
            set_flag(tr, '-')
        else:
            set_flag(tr, '')

    def get_remain(self, udf):
        aoa = get_message_aoa(self.spec, udf)
        next_udf = aoa[0].udf  # col_udf
        if next_udf:
            return self.get_remain(next_udf)
        else:
            return aoa[1:]

    def create_tree_tr(self, d, pad_prefix='', start_level=0):
        treepad = pad_prefix + d.treepad
        level = start_level + d.level
        tr = TR()
        tr.spec = self.spec
        tr.tableview_ie = ">"*level + " " + d.ie
        
        cb = BUTTON("=>", title="append IE")
        cb.bind("click", self.click_append_ie)
        tr <= TD(cb)
        
        td_flag = TD(d.flag, Class="treeflag")
        tr <= td_flag
        if d.flag:
            td_flag.bind("click", click_flag)
            td_flag.title = "click to collapse or expand the IE"

        td_level = TD(level)
        tr <= td_level
        
        ie_td = TD(Class=f"ieselect_td_ie")
        tr <= ie_td
        treepad_span = SPAN(treepad)
        treepad_span.style.fontFamily = "Consolas"
        ie_td <= treepad_span
        ie_span = SPAN(d.ie)
        if d.desc:
            ie_span.title = d.desc
            ie_span.style.color = "blue"
        ie_td <= ie_span
        if d.flag:
            ie_td.bind("click", click_flag)
            ie_td.clickable = ""

        if d.presence == "M":
            tr <= TD(d.presence, Class=f"ieselect_td_presence")
        if d.presence == "O":
            tr <= TD(create_select(["Y", "N"]), Class=f"ieselect_td_presence")

        if d.refer:
            tag = SPAN(d.refer, Class="anchorstyletag", title=d.udf)
            tr <= TD(tag, Class=f"ieselect_td_udf")
            tag.bind("click", self.click_ie)
            tr.udf = d.udf
        else:
            tr <= TD()
            
        if d.value.startswith("ENUMERATED"):
            vt = d.value[len("ENUMERATED"):].strip()[1:-1]
            vl = [_i.strip() for _i in vt.split(",")]
            tr <= TD(create_select(vl, full_size=False), title=d.value, Class=f"ieselect_td_value")
        else:
            tr <= TD(d.value, Class=f"ieselect_td_value")
        return tr








####################################################
####################################################
####################################################







puml_template = """
@startuml

autonumber "<b>0 "
skinparam shadowing false
skinparam roundcorner 2

skinparam ParticipantBackgroundColor lightgrey
skinparam ParticipantBorderColor lightgrey

skinparam NoteBackgroundColor #FFFFA8
skinparam NoteBorderColor lightgrey
skinparam NoteBorderColor white

skinparam SequenceLifeLineBorderColor black

skinparam SequenceArrowColor black

skinparam SequenceGroupBorderColor #4677BF
skinparam SequenceGroupHeaderFontColor #4677BF
skinparam SequenceGroupFontColor #4677BF

skinparam SequenceGroupBorderThickness 1
skinparam SequenceGroupFontStyle normal

skinparam SequenceGroupHeaderFontStyle normal
skinparam SequenceGroupBackgroundColor white

{participant_str}

{content_str}

...
@enduml
"""

html_template = """
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Export MSC</title>
    </head>
    <body>
{msc_desc}
    </body>
</html>
"""

class Msc:
    def __init__(self):
        for tag in document.select("[id]"):
            setattr(self, tag.id, tag)
        self.bind()
        self.btn_edit_participant.style.display = ""
        self.btn_save_participant.style.display = "none"
        self.participant_list = []
        self.trs_dict = {}
        self.appname = "msc.3gpp.plantuml.wrapper@lyg"
        self.appversion = "1.0.0"
        self.ieselect = IESelect(g_spec_list)
        self.imgsrc = ""

    def bind(self):
        for callback_func_name in dir(self):
            if callback_func_name.startswith("callback_"):
                event_name = callback_func_name.split("_")[1]
                element_name = "_".join(callback_func_name.split("_")[2:])
                callback_func = getattr(self, callback_func_name)
                element = getattr(self, element_name)
                element.bind(event_name, callback_func)
                #print(f"self.{element_name}.bind('{event_name}', self.{callback_func_name})")

    def get_msc_row_list(self):
        trs = self.conatiner_msc_table.select("tr.mscrow")
        return [self.trs_dict[tr.id] for tr in trs]

    def callback_click_btn_edit_participant(self, event=None):
        self.btn_edit_participant.style.display = "none"
        self.btn_save_participant.style.display = ""
        self.container_participant_items.clear()
        self.participant_table = ParticipantTable(self.participant_list)
        self.container_participant_items <= self.participant_table.table

    def callback_click_btn_save_participant(self, event=None):
        self.btn_edit_participant.style.display = ""
        self.btn_save_participant.style.display = "none"
        self.participant_list = self.participant_table.get_participant_list()
        self.container_participant_items.clear()
        for s in self.participant_list:
            self.container_participant_items <= BUTTON(s)
        self.refresh_participant()
        self.participant_table = None

    @property
    def participant_list(self):
        return [f'"{i}"' for i in self.participant_list]

    #****************** Message ***************#
    def callback_click_btn_add_message(self, event=None):
        if self.participant_list:
            self.conatiner_msc_table <= MessageTR(self).tr
            self.refresh_common()
        else:
            alert("participant cannot be empty")

    def callback_click_btn_add_note(self, event=None):
        if self.participant_list:    
            self.conatiner_msc_table <= NoteTR(self).tr
            self.refresh_common()
        else:
            alert("participant cannot be empty")

    def callback_click_btn_add_block(self, event=None):
        if self.participant_list:
            self.conatiner_msc_table <= BlockTR(self).tr
            self.refresh_common()
        else:
            alert("participant cannot be empty")

    def callback_click_btn_del_checked(self, event=None):
        for mtr in self.get_msc_row_list():
            if mtr.is_checked():
                mtr.callback_click_btn_del()
        self.refresh_common()
        
    def callback_click_btn_moveup_checked(self, event=None):
        rows = self.get_msc_row_list()
        if not rows[0].is_checked():
            for mtr in rows:
                if mtr.is_checked():
                    mtr.callback_click_btn_up()
        self.refresh_common()
        
    def callback_click_btn_movedown_checked(self, event=None):
        rows = self.get_msc_row_list()[::-1]
        if not rows[0].is_checked():
            for mtr in rows:
                if mtr.is_checked():
                    mtr.callback_click_btn_down()
        self.refresh_common()
        
    def callback_click_btn_save_msc(self, event=None):
        self.refresh_common()
        
        msc_row_list = self.get_msc_row_list()
        lines = [row_obj.line for row_obj in msc_row_list]
        s = "\n".join(lines)
        s = puml_template.format(participant_str=self.participant_str, content_str=s)
        self.url = window.plantuml_url(s)
        self.plantuml_url = window.plantuml_url_for_open(s)
        self.container_output.clear()
        
        container = DIV()
        self.container_output <= container
        
        control_div = DIV(Class="msc_desc_output_div")
        container <= control_div
        control_div <= HR()
        b = BUTTON(B("Copy Below MSC and Description"))
        b.style.fontSize = "medium"
        control_div <= b
        b.bind("click", self.copy_output)
        
        b = BUTTON(B("Export to HTML"))
        b.style.fontSize = "medium"
        control_div <= b
        b.bind("click", self.export_html)
        #
        content_div = DIV()
        self.output_content_div = content_div
        container <= content_div
        img_div = DIV(Class="msc_desc_output_div")
        content_div <= img_div
        desc_div = DIV(Class="msc_desc_output_div")
        content_div <= desc_div
        #
        #img_div <= HR()
        # img_div <= H3("Message Sequence Chart")
        img = IMG()
        window.load_image(self.url, img)
        # if window.location.protocol == "file:":
            # img = IMG()
            # window.load_image(self.url, img)
        # else:
            # img = IMG(src=self.url, crossorigin="anonymous")
        img_div <= img
        img_div <= BR()
        #
        #desc_div <= HR()
        desc_div <= H2("Description")
        table = TABLE()
        desc_div <= table
        table.style.margin = "10px 20px 10px 30px"
        for mtr in msc_row_list:
            if mtr.__name__ == "MessageTR":
                num = mtr._message_no + '.'
                num_td = TD(B(num))
                desc = mtr.description.get_text().replace("\n", "<br>")
                desc_td = TD(desc)
                table <= TR(num_td + desc_td)
                num_td.style.verticalAlign = "top"
                desc_td.style.paddingLeft = "10px"
        # ol = OL()
        # desc_div <= ol
        # for mtr in msc_row_list:
            # if mtr.__name__ == "MessageTR":
                # ol <= LI(mtr.description.get_text().replace("\n", "<br>"))
        # self.container_output <= DIV(HR()+IMG(src=url)+HR()+PRE(s))

    def copy_output(self, event=None):
        copy_element(self.output_content_div)

    def export_html(self, event=None):
        filename = "mscexport.html"
        s = html_template.format(msc_desc=self.output_content_div.html)
        window.download(s, filename, "text/plain");
        
    def callback_click_btn_open_in_plantuml(self, event=None):
        self.callback_click_btn_save_msc()
        url = self.plantuml_url
        self.container_anchor_plantuml.href = url
        window.clickElem(self.container_anchor_plantuml)

    def callback_click_btn_demo(self, event=None):
        f = open(f'./data/demo.json')
        s = f.read()
        self.import_file(s)

    def callback_click_btn_demo2(self, event=None):
        f = open(f'./data/demo2.json')
        s = f.read()
        self.import_file(s)

    def callback_click_btn_toggle_timer(self, event=None):
        btn = event.target
        if btn.text == "Hide Timer":
            btn.text = "Show Timer"
            for t in document.select(".timer"):
                t.style.display = "none"
        else:
            btn.text = "Hide Timer"
            for t in document.select(".timer"):
                t.style.display = ""

    def refresh_common(self):
        self.callback_click_btn_refresh_indent()
        self.refresh_message_no()
    
    def callback_click_btn_refresh_indent(self, event=None):
        next_indent = 0
        # i = 0
        for row in self.get_msc_row_list():
            classname = row.__name__
            if classname in ["MessageTR", "NoteTR"]:
                current_row_indent = next_indent
            elif classname == "BlockTR":
                if row.block in ["alt", "opt", "par", "group"]:
                    current_row_indent = next_indent
                    next_indent += 1
                elif row.block in ["else"]:
                    current_row_indent = next_indent - 1
                elif row.block in ["end"]:
                    current_row_indent = next_indent - 1
                    next_indent -= 1
                else:
                    current_row_indent = next_indent
            else:
                current_row_indent = next_indent
            row.set_indent(current_row_indent)
            # print(i, current_row_indent, classname)
            # i += 1
            
    def refresh_message_no(self):
        cur = 1
        for mtr in self.get_msc_row_list():
            if mtr.__name__ == "MessageTR":
                if mtr.is_auto_message_no():
                    mtr.set_message_no(cur)
                    cur += 1
                else:
                    if mtr.is_blank_message_no():
                        pass
                    else:
                        num, fmt = mtr.get_manual_message_no_and_format()
                        if cur == num:
                            mtr.set_to_auto_message_no_td()
                        cur = num + 1

    def refresh_participant(self):
        for row_obj in self.get_msc_row_list():
            row_obj.update_participant()

    @property
    def participant_str(self):
        return "\n".join(["participant " + f'"{p}"' for p in self.participant_list])

    def callback_click_btn_export_file(self, event):
        filename = "mscexport.json"
        o = self.export_obj()
        s = window.JSON.stringify(o)        
        window.download(s, filename, "text/plain");

    def callback_click_btn_import_file(self, event):
        window.openFile(self.import_file)

    def cleanup(self):
        self.container_output.clear()
        self.participant_list = []
        self.container_participant_items.clear()
        for row_obj in self.get_msc_row_list():
            row_obj.callback_click_btn_del()
        self.imgsrc = ""
        
    def import_file(self, json_str):
        o = window.JSON.parse(json_str)
        if o["name"] == self.appname:
            if o["version"] == self.appversion:
                self.cleanup()
                self.participant_list = o["participant_list"]
                self.callback_click_btn_edit_participant()
                self.callback_click_btn_save_participant()
                for row in o["trs"]:
                    if row.classname == "MessageTR":
                        m = MessageTR(self)
                    if row.classname == "NoteTR":
                        m = NoteTR(self)
                    if row.classname == "BlockTR":
                        m = BlockTR(self)
                    self.conatiner_msc_table <= m.tr
                    m.import_obj(row.data)
                #self.refresh_message_no()
                self.callback_click_btn_save_msc()
                #self.callback_click_btn_refresh_indent()
            else:
                print(o["version"])
                alert("cannot open by current version")
        else:
            print(o["name"])
            alert("The file is not for this App")
        
    def export_obj(self):
        o = dict()
        o["name"] = self.appname
        o["version"] = self.appversion
        o["participant_list"] = self.participant_list
        o["trs"] = []
        for row_obj in self.get_msc_row_list():
            if row_obj.__name__ in ["MessageTR", "NoteTR", "BlockTR"]:
                o["trs"].append(row_obj.export_obj())
        o["imgsrc"] = self.imgsrc
        return o

def copy_element(e):
    window.getSelection().empty()
    range = document.createRange()
    range.selectNode(e)
    window.getSelection().addRange(range)
    document.execCommand('copy')
    window.getSelection().empty()

# app = Msc()
window.g_app = Msc()

        </script>
        
        <!-- <div id="import_content" style="display:none"></div> -->
    </body>
</html>
